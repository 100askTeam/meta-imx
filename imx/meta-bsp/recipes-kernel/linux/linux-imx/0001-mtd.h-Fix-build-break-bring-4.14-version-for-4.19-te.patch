From 9e4999128a847e0e405d63225539b3a58b45b644 Mon Sep 17 00:00:00 2001
From: Lauren Post <lauren.post@nxp.com>
Date: Mon, 18 Feb 2019 12:57:32 -0600
Subject: [PATCH] mtd.h:  Fix build break -bring 4.14 version for 4.19 test

Signed-off-by: Lauren Post <lauren.post@nxp.com>
---
 include/linux/mtd/mtd.h | 61 ++++++++++++++++++++-----------------------------
 1 file changed, 25 insertions(+), 36 deletions(-)

diff --git a/include/linux/mtd/mtd.h b/include/linux/mtd/mtd.h
index cd0be91..6cd0f6b 100644
--- a/include/linux/mtd/mtd.h
+++ b/include/linux/mtd/mtd.h
@@ -30,9 +30,13 @@
 
 #include <asm/div64.h>
 
-#define MTD_FAIL_ADDR_UNKNOWN -1LL
+#define MTD_ERASE_PENDING	0x01
+#define MTD_ERASING		0x02
+#define MTD_ERASE_SUSPEND	0x04
+#define MTD_ERASE_DONE		0x08
+#define MTD_ERASE_FAILED	0x10
 
-struct mtd_info;
+#define MTD_FAIL_ADDR_UNKNOWN -1LL
 
 /*
  * If the erase fails, fail_addr might indicate exactly which block failed. If
@@ -40,9 +44,18 @@ struct mtd_info;
  * or was not specific to any particular block.
  */
 struct erase_info {
+	struct mtd_info *mtd;
 	uint64_t addr;
 	uint64_t len;
 	uint64_t fail_addr;
+	u_long time;
+	u_long retries;
+	unsigned dev;
+	unsigned cell;
+	void (*callback) (struct erase_info *self);
+	u_long priv;
+	u_char state;
+	struct erase_info *next;
 };
 
 struct mtd_erase_region_info {
@@ -67,11 +80,9 @@ struct mtd_erase_region_info {
  * @datbuf:	data buffer - if NULL only oob data are read/written
  * @oobbuf:	oob data buffer
  *
- * Note, some MTD drivers do not allow you to write more than one OOB area at
- * one go. If you try to do that on such an MTD device, -EINVAL will be
- * returned. If you want to make your implementation portable on all kind of MTD
- * devices you should split the write request into several sub-requests when the
- * request crosses a page boundary.
+ * Note, it is allowed to read more than one OOB area at one go, but not write.
+ * The interface assumes that the OOB write requests program only one page's
+ * OOB area.
  */
 struct mtd_oob_ops {
 	unsigned int	mode;
@@ -256,7 +267,7 @@ struct mtd_info {
 	 */
 	unsigned int bitflip_threshold;
 
-	/* Kernel-only stuff starts here. */
+	// Kernel-only stuff starts here.
 	const char *name;
 	int index;
 
@@ -286,6 +297,10 @@ struct mtd_info {
 	int (*_point) (struct mtd_info *mtd, loff_t from, size_t len,
 		       size_t *retlen, void **virt, resource_size_t *phys);
 	int (*_unpoint) (struct mtd_info *mtd, loff_t from, size_t len);
+	unsigned long (*_get_unmapped_area) (struct mtd_info *mtd,
+					     unsigned long len,
+					     unsigned long offset,
+					     unsigned long flags);
 	int (*_read) (struct mtd_info *mtd, loff_t from, size_t len,
 		      size_t *retlen, u_char *buf);
 	int (*_write) (struct mtd_info *mtd, loff_t to, size_t len,
@@ -478,34 +493,6 @@ static inline uint32_t mtd_mod_by_eb(uint64_t sz, struct mtd_info *mtd)
 	return do_div(sz, mtd->erasesize);
 }
 
-/**
- * mtd_align_erase_req - Adjust an erase request to align things on eraseblock
- *			 boundaries.
- * @mtd: the MTD device this erase request applies on
- * @req: the erase request to adjust
- *
- * This function will adjust @req->addr and @req->len to align them on
- * @mtd->erasesize. Of course we expect @mtd->erasesize to be != 0.
- */
-static inline void mtd_align_erase_req(struct mtd_info *mtd,
-				       struct erase_info *req)
-{
-	u32 mod;
-
-	if (WARN_ON(!mtd->erasesize))
-		return;
-
-	mod = mtd_mod_by_eb(req->addr, mtd);
-	if (mod) {
-		req->addr -= mod;
-		req->len += mod;
-	}
-
-	mod = mtd_mod_by_eb(req->addr + req->len, mtd);
-	if (mod)
-		req->len += mtd->erasesize - mod;
-}
-
 static inline uint32_t mtd_div_by_ws(uint64_t sz, struct mtd_info *mtd)
 {
 	if (mtd->writesize_shift)
@@ -584,6 +571,8 @@ extern void register_mtd_user (struct mtd_notifier *new);
 extern int unregister_mtd_user (struct mtd_notifier *old);
 void *mtd_kmalloc_up_to(const struct mtd_info *mtd, size_t *size);
 
+void mtd_erase_callback(struct erase_info *instr);
+
 static inline int mtd_is_bitflip(int err) {
 	return err == -EUCLEAN;
 }
-- 
2.7.4

