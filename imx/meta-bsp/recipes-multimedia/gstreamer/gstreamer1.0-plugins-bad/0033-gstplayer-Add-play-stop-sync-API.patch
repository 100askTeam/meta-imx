From cd3603dc28ae3c56299d4ff6debf1532c85ab26c Mon Sep 17 00:00:00 2001
From: Lyon Wang <lyon.wang@nxp.com>
Date: Thu, 16 Feb 2017 18:50:28 +0800
Subject: [PATCH 2/3] gstplayer: Add play/stop sync API

- Add play/stop/pause sync API
      gst_player_play_sync()
      gst_player_stop_sync()
      gst_player_pause_sync()

https://bugzilla.gnome.org/show_bug.cgi?id=778390

Upstream Status:  [i.MX specific]

Signed-off-by: Lyon Wang <lyon.wang@nxp.com>
---
 gst-libs/gst/player/gstplayer.c | 112 +++++++++++++++++++++++++++++++++++++++-
 gst-libs/gst/player/gstplayer.h |   4 ++
 2 files changed, 115 insertions(+), 1 deletion(-)

diff --git a/gst-libs/gst/player/gstplayer.c b/gst-libs/gst/player/gstplayer.c
index d0aec41..0568347 100644
--- a/gst-libs/gst/player/gstplayer.c
+++ b/gst-libs/gst/player/gstplayer.c
@@ -195,6 +195,10 @@ struct _GstPlayer
    * state-changed:GST_PLAYER_STATE_STOPPED/PAUSED. This ensures that no signal
    * is emitted after gst_player_stop/pause() has been called by the user. */
   gboolean inhibit_sigs;
+
+  /* When error occur, will set this flag to TRUE,
+   * so that it could quit for sync play/stop loop */
+  gboolean got_error;
 };
 
 struct _GstPlayerClass
@@ -279,6 +283,7 @@ gst_player_init (GstPlayer * self)
   self->seek_position = GST_CLOCK_TIME_NONE;
   self->last_seek_time = GST_CLOCK_TIME_NONE;
   self->inhibit_sigs = FALSE;
+  self->got_error = FALSE;
 
   GST_TRACE_OBJECT (self, "Initialized");
 }
@@ -1172,6 +1177,8 @@ error_cb (G_GNUC_UNUSED GstBus * bus, GstMessage * msg, gpointer user_data)
       full_message);
   emit_error (self, player_err);
 
+  self->got_error = TRUE;
+
   g_clear_error (&err);
   g_free (debug);
   g_free (name);
@@ -4589,4 +4596,107 @@ gst_player_get_state (GstPlayer * self)
   g_return_val_if_fail (GST_IS_PLAYER (self), GST_PLAYER_STATE_STOPPED);
 
   return self->app_state;
-}
\ No newline at end of file
+}
+
+/**
+ * gst_player_wait_state
+ * @player: #GstPlayer instance
+ * @target_state: target state
+ * @time_out:  time out value
+ *  negtive (< 0): infinitely waiting for state change.
+ *  positive (>0): wait until time out.
+ *  zero (0), do not wait for the state change.
+ *
+ * Wait for target state, quit loop when time out
+ */
+static void
+gst_player_wait_state (GstPlayer * self, GstPlayerState target_state,
+    gint time_out)
+{
+  gint wait_cnt = 0;
+
+  while (time_out < 0 || wait_cnt < time_out) {
+    if (self->app_state == target_state) {
+      break;
+    } else if (self->got_error == TRUE) {
+      self->got_error = FALSE;
+      return;
+    } else {
+      wait_cnt++;
+      sleep (1);
+    }
+  }
+  if (time_out > 0 && wait_cnt >= time_out) {
+    emit_error (self, g_error_new (GST_PLAYER_ERROR,
+            GST_PLAYER_ERROR_FAILED,
+            "try to play /stop /pause failed, time out"));
+  }
+
+  return;
+}
+
+/**
+ * gst_player_play_sync:
+ * @player: #GstPlayer instance
+ * @time_out:  time out value
+ *  negtive (< 0): infinitely waiting for state change.
+ *  positive (>0): wait until time out.
+ *  zero (0), do not wait for the state change.
+ *
+ * Request to play the loaded stream in sync mode.
+ */
+void
+gst_player_play_sync (GstPlayer * self, gint time_out)
+{
+  g_return_if_fail (GST_IS_PLAYER (self));
+
+  gst_player_play (self);
+
+  gst_player_wait_state (self, GST_PLAYER_STATE_PLAYING, time_out);
+
+  return;
+}
+
+/**
+ * gst_player_stop_sync:
+ * @player: #GstPlayer instance
+ * @time_out:  time out value
+ *  negtive (< 0): infinitely waiting for state change.
+ *  positive (>0): wait until time out.
+ *  zero (0), do not wait for the state change.
+ *
+ *  Stops playing the current stream in sync mode.
+ */
+void
+gst_player_stop_sync (GstPlayer * self, gint time_out)
+{
+  g_return_if_fail (GST_IS_PLAYER (self));
+
+  gst_player_stop (self);
+
+  gst_player_wait_state (self, GST_PLAYER_STATE_STOPPED, time_out);
+
+  return;
+}
+
+/**
+ * gst_player_pause_sync:
+ * @player: #GstPlayer instance
+ * @time_out:  time out value
+ *  negtive (< 0): infinitely waiting for state change.
+ *  positive (>0): wait until time out.
+ *  zero (0), do not wait for the state change.
+ *
+ *  Pause current stream in sync mode.
+ */
+void
+gst_player_pause_sync (GstPlayer * self, gint time_out)
+{
+  g_return_if_fail (GST_IS_PLAYER (self));
+
+  gst_player_pause (self);
+
+  gst_player_wait_state (self, GST_PLAYER_STATE_PAUSED, time_out);
+
+  return;
+}
diff --git a/gst-libs/gst/player/gstplayer.h b/gst-libs/gst/player/gstplayer.h
index 3fb323b..abead10 100644
--- a/gst-libs/gst/player/gstplayer.h
+++ b/gst-libs/gst/player/gstplayer.h
@@ -229,6 +229,10 @@ gboolean    gst_player_set_text_sink (GstPlayer * player, const gchar * sink_nam
 
 GstPlayerState  gst_player_get_state (GstPlayer * player);
 
+void         gst_player_play_sync (GstPlayer * player, gint time_out);
+void         gst_player_stop_sync (GstPlayer * player, gint time_out);
+void         gst_player_pause_sync (GstPlayer * player, gint time_out);
+
 G_END_DECLS
 
 #endif /* __GST_PLAYER_H__ */
-- 
1.9.1

