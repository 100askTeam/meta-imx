From c3d802795458bad2e36d23d6449475984990cc5e Mon Sep 17 00:00:00 2001
From: Haihua Hu <jared.hu@nxp.com>
Date: Tue, 30 Aug 2016 15:55:03 +0800
Subject: [PATCH 2/3] Support one texture for YUV format in dmabuf upload

Upstream-Status: Inappropriate [i.MX specific]

Signed-off-by: Haihua Hu <jared.hu@nxp.com>
---
 gst-libs/gst/gl/egl/gsteglimagememory.c | 130 ++++++++++++++++++++++++++++++++
 gst-libs/gst/gl/egl/gsteglimagememory.h |   2 +
 gst-libs/gst/gl/gstglupload.c           |  18 ++++-
 3 files changed, 149 insertions(+), 1 deletion(-)

diff --git a/gst-libs/gst/gl/egl/gsteglimagememory.c b/gst-libs/gst/gl/egl/gsteglimagememory.c
index 6c5ae47..33013a3 100644
--- a/gst-libs/gst/gl/egl/gsteglimagememory.c
+++ b/gst-libs/gst/gl/egl/gsteglimagememory.c
@@ -424,6 +424,136 @@ _drm_fourcc_from_info (GstVideoInfo * info, int plane)
 }
 
 GstMemory *
+gst_egl_image_memory_from_dmabuf_singleplaner (GstGLContext * context,
+    GstMemory ** mems, GstVideoInfo * in_info, gint n_planes, gsize * offset)
+{
+  GstGLContextEGL *ctx_egl = GST_GL_CONTEXT_EGL (context);
+  GstEGLImageAllocator *allocator;
+  gint fourcc;
+  gint atti = 0;
+  guint i;
+  EGLint attribs[25];
+  EGLint dmafd_flags[] = {
+    EGL_DMA_BUF_PLANE0_FD_EXT,
+    EGL_DMA_BUF_PLANE1_FD_EXT,
+    EGL_DMA_BUF_PLANE2_FD_EXT
+  };
+  EGLint offset_flags[] = {
+    EGL_DMA_BUF_PLANE0_OFFSET_EXT,
+    EGL_DMA_BUF_PLANE1_OFFSET_EXT,
+    EGL_DMA_BUF_PLANE2_OFFSET_EXT
+  };
+  EGLint pitch_flags[] = {
+    EGL_DMA_BUF_PLANE0_PITCH_EXT,
+    EGL_DMA_BUF_PLANE1_PITCH_EXT,
+    EGL_DMA_BUF_PLANE2_PITCH_EXT
+  };
+#ifdef EGL_VERSION_1_5
+  EGLAttrib attribs_1_5[25];
+  EGLAttrib dmafd_flags_1_5[] = {
+    EGL_DMA_BUF_PLANE0_FD_EXT,
+    EGL_DMA_BUF_PLANE1_FD_EXT,
+    EGL_DMA_BUF_PLANE2_FD_EXT
+  };
+  EGLAttrib offset_flags_1_5[] = {
+    EGL_DMA_BUF_PLANE0_OFFSET_EXT,
+    EGL_DMA_BUF_PLANE1_OFFSET_EXT,
+    EGL_DMA_BUF_PLANE2_OFFSET_EXT
+  };
+  EGLAttrib pitch_flags_1_5[] = {
+    EGL_DMA_BUF_PLANE0_PITCH_EXT,
+    EGL_DMA_BUF_PLANE1_PITCH_EXT,
+    EGL_DMA_BUF_PLANE2_PITCH_EXT
+  };
+#endif
+  EGLImageKHR img = EGL_NO_IMAGE_KHR;
+
+  allocator = gst_egl_image_allocator_obtain ();
+  fourcc = _drm_fourcc_from_info (in_info, 0);
+
+  if(GST_VIDEO_INFO_IS_YUV(in_info)) {
+    fourcc = gst_video_format_to_fourcc (GST_VIDEO_INFO_FORMAT(in_info));
+
+    /* gstreamer fourcc is not compatible with DRM FOURCC*/
+    if(GST_VIDEO_INFO_FORMAT(in_info) == GST_VIDEO_FORMAT_I420)
+      fourcc = DRM_FORMAT_YUV420;
+  }
+
+  GST_DEBUG ("fourcc %.4s (%d) n_planes %d (%dx%d)",
+      (char *) &fourcc, fourcc, n_planes,
+      GST_VIDEO_INFO_COMP_WIDTH (in_info, 0),
+      GST_VIDEO_INFO_COMP_HEIGHT (in_info, 0));
+
+#ifdef EGL_VERSION_1_5
+  if (GST_GL_CHECK_GL_VERSION (ctx_egl->egl_major, ctx_egl->egl_minor, 1, 5)) {
+    attribs_1_5[atti++] = EGL_WIDTH;
+    attribs_1_5[atti++] = GST_VIDEO_INFO_WIDTH (in_info);
+    attribs_1_5[atti++] = EGL_HEIGHT;
+    attribs_1_5[atti++] = GST_VIDEO_INFO_HEIGHT (in_info);
+
+    attribs_1_5[atti++] = EGL_LINUX_DRM_FOURCC_EXT;
+    attribs_1_5[atti++] = fourcc;
+
+    for (i = 0; i < n_planes; i++) {
+      attribs_1_5[atti++] = dmafd_flags_1_5[i];
+      attribs_1_5[atti++] = gst_dmabuf_memory_get_fd (mems[i]);
+      attribs_1_5[atti++] = offset_flags_1_5[i];
+      attribs_1_5[atti++] = offset[i];
+      attribs_1_5[atti++] = pitch_flags_1_5[i];
+      attribs_1_5[atti++] = GST_VIDEO_INFO_PLANE_STRIDE (in_info, i);
+    }
+
+    attribs_1_5[atti] = EGL_NONE;
+
+    for (int i = 0; i < atti; i++)
+      GST_LOG ("attr %i: %" G_GINTPTR_FORMAT, i, attribs_1_5[i]);
+
+    g_assert (atti <= 25);
+
+    img = ctx_egl->eglCreateImage (ctx_egl->egl_display, EGL_NO_CONTEXT,
+        EGL_LINUX_DMA_BUF_EXT, NULL, attribs_1_5);
+  } else
+#endif
+  {
+    attribs[atti++] = EGL_WIDTH;
+    attribs[atti++] = GST_VIDEO_INFO_WIDTH (in_info);
+    attribs[atti++] = EGL_HEIGHT;
+    attribs[atti++] = GST_VIDEO_INFO_HEIGHT (in_info);
+
+    attribs[atti++] = EGL_LINUX_DRM_FOURCC_EXT;
+    attribs[atti++] = fourcc;
+
+    for (i = 0; i < n_planes; i++) {
+      attribs[atti++] = dmafd_flags[i];
+      attribs[atti++] = gst_dmabuf_memory_get_fd (mems[i]);
+      attribs[atti++] = offset_flags[i];
+      attribs[atti++] = offset[i];
+      attribs[atti++] = pitch_flags[i];
+      attribs[atti++] = GST_VIDEO_INFO_PLANE_STRIDE (in_info, i);
+    }
+
+    attribs[atti] = EGL_NONE;
+
+    for (int i = 0; i < atti; i++)
+      GST_LOG ("attr %i: %" G_GINTPTR_FORMAT, i, attribs[i]);
+
+    g_assert (atti <= 25);
+
+    img = ctx_egl->eglCreateImage (ctx_egl->egl_display, EGL_NO_CONTEXT,
+        EGL_LINUX_DMA_BUF_EXT, NULL, attribs);
+  }
+
+  if (!img) {
+    GST_WARNING_OBJECT (allocator, "eglCreateImage failed: %s",
+        gst_gl_context_egl_get_error_string (eglGetError ()));
+    return NULL;
+  }
+
+  return gst_egl_image_allocator_wrap (allocator, ctx_egl, img, 0, 0,
+      in_info->size, NULL, NULL);
+}
+
+GstMemory *
 gst_egl_image_memory_from_dmabuf (GstGLContext * context,
     gint dmabuf, GstVideoInfo * in_info, gint plane, gsize offset)
 {
diff --git a/gst-libs/gst/gl/egl/gsteglimagememory.h b/gst-libs/gst/gl/egl/gsteglimagememory.h
index aced247..66c770a 100644
--- a/gst-libs/gst/gl/egl/gsteglimagememory.h
+++ b/gst-libs/gst/gl/egl/gsteglimagememory.h
@@ -67,6 +67,8 @@ void gst_egl_image_memory_set_orientation (GstMemory * mem,
 #if GST_GL_HAVE_DMABUF
 GstMemory * gst_egl_image_memory_from_dmabuf (GstGLContext * context,
     gint dmabuf, GstVideoInfo * in_info, gint plane, gsize offset);
+GstMemory * gst_egl_image_memory_from_dmabuf_singleplaner (GstGLContext * context,
+    GstMemory ** mems, GstVideoInfo * in_info, gint n_planes, gsize * offset);
 #endif
 
 G_END_DECLS
diff --git a/gst-libs/gst/gl/gstglupload.c b/gst-libs/gst/gl/gstglupload.c
index 3b30455..fbef086 100644
--- a/gst-libs/gst/gl/gstglupload.c
+++ b/gst-libs/gst/gl/gstglupload.c
@@ -913,7 +913,7 @@ _dma_buf_upload_accept (gpointer impl, GstBuffer * buffer, GstCaps * in_caps,
     gst_gl_allocation_params_free ((GstGLAllocationParams *) dmabuf->params);
   if (!(dmabuf->params =
           gst_gl_video_allocation_params_new (dmabuf->upload->context, NULL,
-              &dmabuf->upload->priv->in_info, -1, NULL,
+              &dmabuf->upload->priv->out_info, -1, NULL,
               GST_GL_TEXTURE_TARGET_2D)))
     return FALSE;
 
@@ -939,6 +939,21 @@ _dma_buf_upload_accept (gpointer impl, GstBuffer * buffer, GstCaps * in_caps,
       return FALSE;
   }
 
+#ifdef EGL_DMA_BUF_PLANE1_FD_EXT
+  /* Now create one single EGLImage */
+  /* check if one is cached */
+  dmabuf->eglimage[0] = _get_cached_eglimage (mems[0], 0);
+  if (dmabuf->eglimage[0])
+    return TRUE;
+
+  dmabuf->eglimage[0] =
+      gst_egl_image_memory_from_dmabuf_singleplaner (dmabuf->upload->context,
+      mems, in_info, n_planes, mems_skip);
+  if (!dmabuf->eglimage[0])
+    return FALSE;
+
+  _set_cached_eglimage (mems[0], dmabuf->eglimage[0], 0);
+#else
   /* Now create an EGLImage for each dmabufs */
   for (i = 0; i < n_planes; i++) {
     /* check if one is cached */
@@ -956,6 +971,7 @@ _dma_buf_upload_accept (gpointer impl, GstBuffer * buffer, GstCaps * in_caps,
 
     _set_cached_eglimage (mems[i], dmabuf->eglimage[i], i);
   }
+#endif
 
   return TRUE;
 }
-- 
1.9.1

