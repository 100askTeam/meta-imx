From 103de36db7859862b8a612e333ef049a6b39c018 Mon Sep 17 00:00:00 2001
From: Haihua Hu <jared.hu@nxp.com>
Date: Thu, 4 Aug 2016 10:52:15 +0800
Subject: [PATCH] qt: implement qmlglsrc for qml view grab

Upstream-Status: Backport [1.9.2]

https://bugzilla.gnome.org/show_bug.cgi?id=768160

Signed-off-by: Haihua Hu <jared.hu@nxp.com>
---
 ext/qt/Makefile.am       |  28 ++-
 ext/qt/gstplugin.cc      |   8 +-
 ext/qt/gstqtglutility.cc | 211 ++++++++++++++++
 ext/qt/gstqtglutility.h  |  34 +++
 ext/qt/gstqtsrc.cc       | 607 +++++++++++++++++++++++++++++++++++++++++++++++
 ext/qt/gstqtsrc.h        |  82 +++++++
 ext/qt/qtitem.cc         | 154 +-----------
 ext/qt/qtwindow.cc       | 371 +++++++++++++++++++++++++++++
 ext/qt/qtwindow.h        |  70 ++++++
 9 files changed, 1404 insertions(+), 161 deletions(-)
 create mode 100644 ext/qt/gstqtglutility.cc
 create mode 100644 ext/qt/gstqtglutility.h
 create mode 100644 ext/qt/gstqtsrc.cc
 create mode 100644 ext/qt/gstqtsrc.h
 create mode 100644 ext/qt/qtwindow.cc
 create mode 100644 ext/qt/qtwindow.h

diff --git a/ext/qt/Makefile.am b/ext/qt/Makefile.am
index eab3e97..5547e96 100644
--- a/ext/qt/Makefile.am
+++ b/ext/qt/Makefile.am
@@ -1,29 +1,37 @@
-plugin_LTLIBRARIES = libgstqtsink.la
+plugin_LTLIBRARIES = libgstqmlgl.la
 
 noinst_HEADERS = \
 	gstqsgtexture.h \
+	gstqtglutility.h \
 	gstqtsink.h \
-	qtitem.h
+	gstqtsrc.h \
+	qtitem.h \
+	qtwindow.h
 
 moc_generated = \
 	moc_qtitem.cc \
+	moc_qtwindow.cc \
 	moc_gstqsgtexture.cc
 
 #anything generated by the Qt tools...
 BUILT_SOURCES = $(moc_generated)
 CLEANFILES = $(moc_generated)
 
-nodist_libgstqtsink_la_SOURCES = $(BUILT_SOURCES)
+nodist_libgstqmlgl_la_SOURCES = $(BUILT_SOURCES)
 
-libgstqtsink_la_SOURCES = \
+libgstqmlgl_la_SOURCES = \
 	gstqsgtexture.cc \
+	gstqtglutility.cc \
 	qtitem.cc \
+	qtwindow.cc \
 	gstqtsink.cc \
 	gstqtsink.h \
-	gstqtgl.h \
-	gstplugin.cc
+	gstqtsrc.cc \
+	gstqtsrc.h \
+ 	gstqtgl.h \
+ 	gstplugin.cc
 
-libgstqtsink_la_CXXFLAGS = \
+libgstqmlgl_la_CXXFLAGS = \
 	-I$(top_srcdir)/gst-libs \
 	-I$(top_builddir)/gst-libs \
 	-I$(QPA_INCLUDE_PATH) \
@@ -33,15 +41,15 @@ libgstqtsink_la_CXXFLAGS = \
 	$(QT_CFLAGS) \
 	$(GL_CFLAGS)
 
-libgstqtsink_la_LIBADD = \
+libgstqmlgl_la_LIBADD = \
 	$(GST_BASE_LIBS) \
 	$(GST_PLUGINS_BASE_LIBS) \
 	$(QT_LIBS) \
 	$(top_builddir)/gst-libs/gst/gl/libgstgl-$(GST_API_VERSION).la \
 	-lgstvideo-$(GST_API_VERSION)
 
-libgstqtsink_la_LDFLAGS = $(GST_PLUGIN_LDFLAGS)
-libgstqtsink_la_LIBTOOLFLAGS = $(GST_PLUGIN_LIBTOOLFLAGS)
+libgstqmlgl_la_LDFLAGS = $(GST_PLUGIN_LDFLAGS)
+libgstqmlgl_la_LIBTOOLFLAGS = $(GST_PLUGIN_LIBTOOLFLAGS)
 
 
 $(moc_generated): moc_%.cc: %.h
diff --git a/ext/qt/gstplugin.cc b/ext/qt/gstplugin.cc
index 2fa10f5..01ca275 100644
--- a/ext/qt/gstplugin.cc
+++ b/ext/qt/gstplugin.cc
@@ -23,6 +23,7 @@
 #endif
 
 #include "gstqtsink.h"
+#include "gstqtsrc.h"
 #include <QtQml/QQmlApplicationEngine>
 
 static gboolean
@@ -32,6 +33,11 @@ plugin_init (GstPlugin * plugin)
           GST_RANK_NONE, GST_TYPE_QT_SINK)) {
     return FALSE;
   }
+  
+  if (!gst_element_register (plugin, "qmlglsrc",
+          GST_RANK_NONE, GST_TYPE_QT_SRC)) {
+    return FALSE;
+  }
   /* this means the plugin must be loaded before the qml engine is loaded */
   qmlRegisterType<QtGLVideoItem> ("org.freedesktop.gstreamer.GLVideoItem", 1, 0, "GstGLVideoItem");
 
@@ -41,6 +47,6 @@ plugin_init (GstPlugin * plugin)
 GST_PLUGIN_DEFINE (GST_VERSION_MAJOR,
     GST_VERSION_MINOR,
     qt,
-    "Qt sink",
+    "Qt gl plugin",
     plugin_init, PACKAGE_VERSION, GST_LICENSE, GST_PACKAGE_NAME,
     GST_PACKAGE_ORIGIN)
diff --git a/ext/qt/gstqtglutility.cc b/ext/qt/gstqtglutility.cc
new file mode 100644
index 0000000..3753037
--- /dev/null
+++ b/ext/qt/gstqtglutility.cc
@@ -0,0 +1,211 @@
+/*
+ * GStreamer
+ * Copyright (C) 2016 Freescale Semiconductor, Inc. All rights reserved.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "gstqtglutility.h"
+#include <QtGui/QGuiApplication>
+
+#if GST_GL_HAVE_WINDOW_X11 && GST_GL_HAVE_PLATFORM_GLX && defined (HAVE_QT_X11)
+#include <QX11Info>
+#include <gst/gl/x11/gstgldisplay_x11.h>
+#include <gst/gl/x11/gstglcontext_glx.h>
+#endif
+
+#if GST_GL_HAVE_WINDOW_WAYLAND && GST_GL_HAVE_PLATFORM_EGL && defined (HAVE_QT_WAYLAND)
+#include <qpa/qplatformnativeinterface.h>
+#include <gst/gl/wayland/gstgldisplay_wayland.h>
+#endif
+
+#if GST_GL_HAVE_PLATFORM_EGL && defined (HAVE_QT_EGLFS)
+#include <gst/gl/egl/gstgldisplay_egl.h>
+#include <gst/gl/egl/gstglcontext_egl.h>
+#endif
+
+#if GST_GL_HAVE_WINDOW_COCOA && GST_GL_HAVE_PLATFORM_COCOA && defined (HAVE_QT_MAC)
+#include <gst/gl/coaoa/gstgldisplay_cocoa.h>
+#endif
+
+#define GST_CAT_DEFAULT qt_gl_utils_debug
+GST_DEBUG_CATEGORY_STATIC (GST_CAT_DEFAULT);
+
+GstGLDisplay *
+gst_qt_get_gl_display ()
+{
+  GstGLDisplay *display = NULL;
+  QGuiApplication *app = static_cast<QGuiApplication *> (QCoreApplication::instance ());
+  static volatile gsize _debug;
+
+  g_assert (app != NULL);
+
+  GST_INFO ("QGuiApplication::instance()->platformName() %s", app->platformName().toUtf8().data());
+
+  if (g_once_init_enter (&_debug)) {
+    GST_DEBUG_CATEGORY_INIT (GST_CAT_DEFAULT, "qtglutility", 0,
+        "Qt gl utility functions");
+    g_once_init_leave (&_debug, 1);
+  }
+
+#if GST_GL_HAVE_WINDOW_X11 && defined (HAVE_QT_X11)
+  if (QString::fromUtf8 ("xcb") == app->platformName())
+    display = (GstGLDisplay *)
+        gst_gl_display_x11_new_with_display (QX11Info::display ());
+#endif
+#if GST_GL_HAVE_WINDOW_WAYLAND && GST_GL_HAVE_PLATFORM_EGL && defined (HAVE_QT_WAYLAND)
+  if (QString::fromUtf8 ("wayland") == app->platformName()
+        || QString::fromUtf8 ("wayland-egl") == app->platformName()){
+    struct wl_display * wayland_display;
+    QPlatformNativeInterface *native =
+        QGuiApplication::platformNativeInterface();
+    wayland_display = (struct wl_display *)
+        native->nativeResourceForWindow("display", NULL);
+    display = (GstGLDisplay *)
+        gst_gl_display_wayland_new_with_display (wayland_display);
+  }
+#endif
+#if GST_GL_HAVE_PLATFORM_EGL && GST_GL_HAVE_WINDOW_ANDROID
+  if (QString::fromUtf8 ("android") == app->platformName())
+    display = (GstGLDisplay *) gst_gl_display_egl_new ();
+#elif GST_GL_HAVE_PLATFORM_EGL && defined (HAVE_QT_EGLFS)
+  if (QString::fromUtf8("eglfs") == app->platformName())
+    display = (GstGLDisplay *) gst_gl_display_egl_new ();
+#endif
+
+#if GST_GL_HAVE_WINDOW_COCOA && GST_GL_HAVE_PLATFORM_COCOA && defined (HAVE_QT_MAC)
+  if (QString::fromUtf8 ("cocoa") == app->platformName())
+    display = (GstGLDisplay *) gst_gl_display_cocoa_new ();
+#endif
+#if GST_GL_HAVE_WINDOW_EAGL && GST_GL_HAVE_PLATFORM_EAGL && defined (HAVE_QT_IOS)
+  if (QString::fromUtf8 ("ios") == app->platformName())
+    display = gst_gl_display_new ();
+#endif
+#if GST_GL_HAVE_WINDOW_WIN32 && GST_GL_HAVE_PLATFORM_WGL && defined (HAVE_QT_WIN32)
+  if (QString::fromUtf8 ("windows") == app->platformName())
+    display = gst_gl_display_new ();
+#endif
+
+  if (!display)
+    display = gst_gl_display_new ();
+
+  return display;
+}
+
+gboolean
+gst_qt_get_gl_wrapcontext (GstGLDisplay * display,
+    GstGLContext **wrap_glcontext, GstGLContext **context)
+{
+  GstGLPlatform platform = (GstGLPlatform) 0;
+  GstGLAPI gl_api;
+  guintptr gl_handle;
+  GError *error = NULL;
+
+  g_return_val_if_fail (display != NULL && wrap_glcontext != NULL, FALSE);
+
+#if GST_GL_HAVE_WINDOW_X11 && defined (HAVE_QT_X11)
+  if (GST_IS_GL_DISPLAY_X11 (display)) {
+    platform = GST_GL_PLATFORM_GLX;
+  }
+#endif
+#if GST_GL_HAVE_WINDOW_WAYLAND && defined (HAVE_QT_WAYLAND)
+  if (GST_IS_GL_DISPLAY_WAYLAND (display)) {
+    platform = GST_GL_PLATFORM_EGL;
+  }
+#endif
+#if GST_GL_HAVE_PLATFORM_EGL && defined (HAVE_QT_EGLFS)
+  if (GST_IS_GL_DISPLAY_EGL (display)) {
+    platform = GST_GL_PLATFORM_EGL;
+  }
+#endif
+  if (platform == 0) {
+#if GST_GL_HAVE_WINDOW_COCOA && GST_GL_HAVE_PLATFORM_COCOA && defined (HAVE_QT_MAC)
+    platform = GST_GL_PLATFORM_CGL;
+#elif GST_GL_HAVE_WINDOW_EAGL && GST_GL_HAVE_PLATFORM_EAGL && defined (HAVE_QT_IOS)
+    platform = GST_GL_PLATFORM_EAGL;
+#elif GST_GL_HAVE_WINDOW_WIN32 && GST_GL_HAVE_PLATFORM_WGL && defined (HAVE_QT_WIN32)
+    platform = GST_GL_PLATFORM_WGL;
+#else
+    GST_ERROR ("Unknown platform");
+    return FALSE;
+#endif
+  }
+
+  gl_api = gst_gl_context_get_current_gl_api (platform, NULL, NULL);
+  gl_handle = gst_gl_context_get_current_gl_context (platform);
+  if (gl_handle)
+    *wrap_glcontext =
+        gst_gl_context_new_wrapped (display, gl_handle,
+        platform, gl_api);
+
+  if (!*wrap_glcontext) {
+    GST_ERROR ("cannot wrap qt OpenGL context");
+    return FALSE;
+  }
+ 
+  (void) platform;
+  (void) gl_api;
+  (void) gl_handle;
+
+  gst_gl_context_activate (*wrap_glcontext, TRUE);
+  if (!gst_gl_context_fill_info (*wrap_glcontext, &error)) {
+    GST_ERROR ("failed to retrieve qt context info: %s", error->message);
+    g_object_unref (*wrap_glcontext);
+    *wrap_glcontext = NULL;
+    return FALSE;
+  } else {
+    gst_gl_display_filter_gl_api (display, gst_gl_context_get_gl_api (*wrap_glcontext));
+#if GST_GL_HAVE_WINDOW_WIN32 && GST_GL_HAVE_PLATFORM_WGL && defined (HAVE_QT_WIN32)  
+    g_return_val_if_fail (context != NULL, FALSE);
+
+    if (!wglGetProcAddress ("wglCreateContextAttribsARB")) {
+      GstGLWindow *window;
+      HDC device;
+
+      /* If there's no wglCreateContextAttribsARB() support, then we would fallback to
+       * wglShareLists() which will fail with ERROR_BUSY (0xaa) if either of the GL
+       * contexts are current in any other thread.
+       *
+       * The workaround here is to temporarily disable Qt's GL context while we
+       * set up our own.
+       */
+      *context = gst_gl_context_new (display);
+      window = gst_gl_context_get_window (*context);
+      device = (HDC) gst_gl_window_get_display (window);
+
+      wglMakeCurrent (device, 0);
+      gst_object_unref (window);
+      if (!gst_gl_context_create (*context, *wrap_glcontext, &error)) {
+        GST_ERROR ("%p failed to create shared GL context: %s", this, error->message);
+        g_object_unref (*context);
+        *context = NULL;
+        g_object_unref (*wrap_glcontext);
+        *wrap_glcontext = NULL;
+        wglMakeCurrent (device, (HGLRC) gl_handle);
+        return FALSE;
+      }
+      wglMakeCurrent (device, (HGLRC) gl_handle);
+    }
+#endif
+    gst_gl_context_activate (*wrap_glcontext, FALSE);
+  }
+
+  return TRUE;
+}
diff --git a/ext/qt/gstqtglutility.h b/ext/qt/gstqtglutility.h
new file mode 100644
index 0000000..ca90237
--- /dev/null
+++ b/ext/qt/gstqtglutility.h
@@ -0,0 +1,34 @@
+/*
+ * GStreamer
+ * Copyright (C) 2016 Freescale Semiconductor, Inc. All rights reserved.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef __QT_GL_UTILS_H__
+#define __QT_GL_UTILS_H__
+
+#include <gst/gst.h>
+#include <gst/gl/gl.h>
+
+G_BEGIN_DECLS
+
+GstGLDisplay * gst_qt_get_gl_display ();
+gboolean       gst_qt_get_gl_wrapcontext (GstGLDisplay * display,
+    GstGLContext **wrap_glcontext, GstGLContext **context);
+
+G_END_DECLS
+#endif /* __QT_GL_UTILS_H__ */
diff --git a/ext/qt/gstqtsrc.cc b/ext/qt/gstqtsrc.cc
new file mode 100644
index 0000000..084e473
--- /dev/null
+++ b/ext/qt/gstqtsrc.cc
@@ -0,0 +1,607 @@
+/*
+ * GStreamer
+ * Copyright (C) 2016 Freescale Semiconductor, Inc. All rights reserved.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+/**
+ * SECTION:qmlglsrc
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "gstqtsrc.h"
+#include <gst/video/gstvideoaffinetransformationmeta.h>
+#include <QtGui/QGuiApplication>
+
+#define GST_CAT_DEFAULT gst_debug_qt_gl_src
+GST_DEBUG_CATEGORY (GST_CAT_DEFAULT);
+
+#define DEFAULT_IS_LIVE TRUE
+
+static void gst_qt_src_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec);
+static void gst_qt_src_get_property (GObject * object, guint prop_id,
+    GValue * value, GParamSpec * pspec);
+
+static void gst_qt_src_finalize (GObject * object);
+
+static gboolean gst_qt_src_setcaps (GstBaseSrc * bsrc, GstCaps * caps);
+static GstCaps *gst_qt_src_get_caps (GstBaseSrc * bsrc, GstCaps * filter);
+static gboolean gst_qt_src_query (GstBaseSrc * bsrc, GstQuery * query);
+
+static gboolean gst_qt_src_decide_allocation (GstBaseSrc * bsrc,
+    GstQuery * query);
+static GstFlowReturn gst_qt_src_fill (GstPushSrc * psrc, GstBuffer * buffer);
+static GstStateChangeReturn gst_qt_src_change_state (GstElement * element,
+    GstStateChange transition);
+static gboolean gst_qt_src_start (GstBaseSrc * basesrc);
+static gboolean gst_qt_src_stop (GstBaseSrc * basesrc);
+
+static GstStaticPadTemplate gst_qt_src_template =
+GST_STATIC_PAD_TEMPLATE ("src",
+    GST_PAD_SRC,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS ("video/x-raw(" GST_CAPS_FEATURE_MEMORY_GL_MEMORY "), "
+        "format = (string) RGBA, "
+        "width = " GST_VIDEO_SIZE_RANGE ", "
+        "height = " GST_VIDEO_SIZE_RANGE ", "
+        "framerate = " GST_VIDEO_FPS_RANGE ", "
+        "texture-target = (string) 2D"));
+
+enum
+{
+  ARG_0,
+  PROP_WINDOW,
+  PROP_DEFAULT_FBO
+};
+
+#define gst_qt_src_parent_class parent_class
+G_DEFINE_TYPE_WITH_CODE (GstQtSrc, gst_qt_src,
+    GST_TYPE_PUSH_SRC, GST_DEBUG_CATEGORY_INIT (GST_CAT_DEFAULT,
+        "qtsrc", 0, "Qt Video Src"));
+
+static const gfloat vertical_flip_matrix[] = {
+  1.0f, 0.0f, 0.0f, 0.0f,
+  0.0f, -1.0f, 0.0f, 1.0f,
+  0.0f, 0.0f, 1.0f, 0.0f,
+  0.0f, 0.0f, 0.0f, 1.0f,
+};
+
+static void
+gst_qt_src_class_init (GstQtSrcClass * klass)
+{
+  GObjectClass *gobject_class = (GObjectClass *) klass;
+  GstElementClass *gstelement_class = (GstElementClass *) klass;
+  GstBaseSrcClass *gstbasesrc_class = (GstBaseSrcClass *) klass;
+  GstPushSrcClass *gstpushsrc_class = (GstPushSrcClass *) klass;
+
+  gobject_class->set_property = gst_qt_src_set_property;
+  gobject_class->get_property = gst_qt_src_get_property;
+  gobject_class->finalize = gst_qt_src_finalize;
+
+  gst_element_class_set_metadata (gstelement_class, "Qt Video Source",
+      "Source/Video", "A video src the grab window from a qml view",
+      "Multimedia Team <shmmmw@freescale.com>");
+
+  g_object_class_install_property (gobject_class, PROP_WINDOW,
+      g_param_spec_pointer ("window", "QQuickWindow",
+          "The QQuickWindow to place in the object heirachy",
+          (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
+
+  g_object_class_install_property (gobject_class, PROP_DEFAULT_FBO,
+      g_param_spec_boolean ("use-default-fbo",
+          "If use default fbo",
+          "When set TRUE, it will not create new fbo for qml render thread",
+          FALSE, (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
+
+  gst_element_class_add_pad_template (gstelement_class,
+      gst_static_pad_template_get (&gst_qt_src_template));
+
+  gstelement_class->change_state = gst_qt_src_change_state;
+  gstbasesrc_class->set_caps = gst_qt_src_setcaps;
+  gstbasesrc_class->get_caps = gst_qt_src_get_caps;
+  gstbasesrc_class->query = gst_qt_src_query;
+  gstbasesrc_class->start = gst_qt_src_start;
+  gstbasesrc_class->stop = gst_qt_src_stop;
+  gstbasesrc_class->decide_allocation = gst_qt_src_decide_allocation;
+
+  gstpushsrc_class->fill = gst_qt_src_fill;
+}
+
+static void
+gst_qt_src_init (GstQtSrc * src)
+{
+  gst_base_src_set_format (GST_BASE_SRC (src), GST_FORMAT_TIME);
+  gst_base_src_set_live (GST_BASE_SRC (src), DEFAULT_IS_LIVE);
+  src->default_fbo = FALSE;
+  src->pending_image_orientation = TRUE;
+}
+
+static void
+gst_qt_src_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec)
+{
+  GstQtSrc *qt_src = GST_QT_SRC (object);
+
+  switch (prop_id) {
+    case PROP_WINDOW:{
+      qt_src->qwindow =
+          static_cast < QQuickWindow * >(g_value_get_pointer (value));
+
+      if (qt_src->window)
+        delete qt_src->window;
+      if (qt_src->qwindow)
+        qt_src->window = new QtGLWindow (NULL, qt_src->qwindow);
+
+      break;
+    }
+    case PROP_DEFAULT_FBO:
+      qt_src->default_fbo = g_value_get_boolean (value);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+static void
+gst_qt_src_get_property (GObject * object, guint prop_id,
+    GValue * value, GParamSpec * pspec)
+{
+  GstQtSrc *qt_src = GST_QT_SRC (object);
+
+  switch (prop_id) {
+    case PROP_WINDOW:
+      g_value_set_pointer (value, qt_src->qwindow);
+      break;
+    case PROP_DEFAULT_FBO:
+      g_value_set_boolean (value, qt_src->default_fbo);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+static void
+gst_qt_src_finalize (GObject * object)
+{
+  GstQtSrc *qt_src = GST_QT_SRC (object);
+
+  GST_DEBUG ("qmlglsrc finalize");
+  if (qt_src->context)
+    gst_object_unref (qt_src->context);
+  qt_src->context = NULL;
+
+  if (qt_src->qt_context)
+    gst_object_unref (qt_src->qt_context);
+  qt_src->qt_context = NULL;
+
+  if (qt_src->display)
+    gst_object_unref (qt_src->display);
+  qt_src->display = NULL;
+
+  if (qt_src->window)
+    delete qt_src->window;
+
+  G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+static gboolean
+gst_qt_src_setcaps (GstBaseSrc * bsrc, GstCaps * caps)
+{
+  GstQtSrc *qt_src = GST_QT_SRC (bsrc);
+
+  GST_DEBUG ("set caps with %" GST_PTR_FORMAT, caps);
+
+  if (!gst_video_info_from_caps (&qt_src->v_info, caps))
+    return FALSE;
+
+  if (!qt_window_set_caps (qt_src->window, caps))
+    return FALSE;
+
+  return TRUE;
+}
+
+static GstCaps *
+gst_qt_src_get_caps (GstBaseSrc * bsrc, GstCaps * filter)
+{
+  GstCaps *caps = NULL, *temp = NULL;
+  GstPadTemplate *pad_template;
+  GstBaseSrcClass *bclass = GST_BASE_SRC_GET_CLASS (bsrc);
+  GstQtSrc *qt_src = GST_QT_SRC (bsrc);
+  guint i;
+  gint width, height;
+
+  if (qt_src->window) {
+    qt_src->window->getGeometry (&width, &height);
+  }
+
+  pad_template =
+      gst_element_class_get_pad_template (GST_ELEMENT_CLASS (bclass), "src");
+  if (pad_template != NULL)
+    caps = gst_pad_template_get_caps (pad_template);
+
+  if (qt_src->window) {
+    temp = gst_caps_copy (caps);
+    guint n_caps = gst_caps_get_size (caps);
+
+    for (i = 0; i < n_caps; i++) {
+      GstStructure *s = gst_caps_get_structure (temp, i);
+      gst_structure_set (s, "width", G_TYPE_INT, width, NULL);
+      gst_structure_set (s, "height", G_TYPE_INT, height, NULL);
+      /* because the framerate is unknown */
+      gst_structure_set (s, "framerate", GST_TYPE_FRACTION, 0, 1, NULL);
+      gst_structure_set (s, "pixel-aspect-ratio",
+          GST_TYPE_FRACTION, 1, 1, NULL);
+    }
+
+    gst_caps_unref (caps);
+    caps = temp;
+  }
+
+  if (filter) {
+    GstCaps *intersection;
+
+    intersection =
+        gst_caps_intersect_full (filter, caps, GST_CAPS_INTERSECT_FIRST);
+    gst_caps_unref (caps);
+    caps = intersection;
+  }
+
+  return caps;
+}
+
+static gboolean
+gst_qt_src_query (GstBaseSrc * bsrc, GstQuery * query)
+{
+  GstQtSrc *qt_src = GST_QT_SRC (bsrc);
+  gboolean res = FALSE;
+
+  switch (GST_QUERY_TYPE (query)) {
+    case GST_QUERY_CONTEXT:
+    {
+      const gchar *context_type;
+      GstContext *context, *old_context;
+      gboolean ret;
+
+      if (!qt_window_is_scenegraph_initialized (qt_src->window))
+        return FALSE;
+
+      if (!qt_src->display && !qt_src->qt_context) {
+        qt_src->display = qt_window_get_display (qt_src->window);
+        qt_src->qt_context = qt_window_get_qt_context (qt_src->window);
+      }
+
+      ret = gst_gl_handle_context_query ((GstElement *) qt_src, query,
+          &qt_src->display, &qt_src->qt_context);
+
+      if (qt_src->display)
+        gst_gl_display_filter_gl_api (qt_src->display,
+            gst_gl_context_get_gl_api (qt_src->qt_context));
+
+      gst_query_parse_context_type (query, &context_type);
+
+      if (g_strcmp0 (context_type, "gst.gl.app_context") == 0) {
+        GstStructure *s;
+
+        gst_query_parse_context (query, &old_context);
+
+        if (old_context)
+          context = gst_context_copy (old_context);
+        else
+          context = gst_context_new ("gst.gl.app_context", FALSE);
+
+        s = gst_context_writable_structure (context);
+        gst_structure_set (s, "context", GST_GL_TYPE_CONTEXT,
+            qt_src->qt_context, NULL);
+        gst_query_set_context (query, context);
+        gst_context_unref (context);
+
+        ret = qt_src->qt_context != NULL;
+      }
+      GST_LOG_OBJECT (qt_src, "context query of type %s %i", context_type, ret);
+
+      if (ret)
+        return ret;
+
+      /* fallthrough */
+    }
+    default:
+      res = GST_BASE_SRC_CLASS (parent_class)->query (bsrc, query);
+      break;
+  }
+
+  return res;
+}
+
+static gboolean
+_find_local_gl_context (GstQtSrc * qt_src)
+{
+  GstQuery *query;
+  GstContext *context;
+  const GstStructure *s;
+
+  if (qt_src->context)
+    return TRUE;
+
+  query = gst_query_new_context ("gst.gl.local_context");
+  if (!qt_src->context
+      && gst_gl_run_query (GST_ELEMENT (qt_src), query, GST_PAD_SRC)) {
+    gst_query_parse_context (query, &context);
+    if (context) {
+      s = gst_context_get_structure (context);
+      gst_structure_get (s, "context", GST_GL_TYPE_CONTEXT, &qt_src->context,
+          NULL);
+    }
+  }
+
+  GST_DEBUG_OBJECT (qt_src, "found local context %p", qt_src->context);
+
+  gst_query_unref (query);
+
+  if (qt_src->context)
+    return TRUE;
+
+  return FALSE;
+}
+
+static gboolean
+gst_qt_src_decide_allocation (GstBaseSrc * bsrc, GstQuery * query)
+{
+  GstBufferPool *pool = NULL;
+  GstStructure *config;
+  GstCaps *caps;
+  guint min, max, size, n, i;
+  gboolean update_pool, update_allocator;
+  GstAllocator *allocator;
+  GstAllocationParams params;
+  GstGLVideoAllocationParams *glparams;
+  GstVideoInfo vinfo;
+  GstQtSrc *qt_src = GST_QT_SRC (bsrc);
+
+  if (gst_query_find_allocation_meta (query,
+          GST_VIDEO_AFFINE_TRANSFORMATION_META_API_TYPE, NULL)) {
+    qt_src->downstream_supports_affine_meta = TRUE;
+  } else {
+    qt_src->downstream_supports_affine_meta = FALSE;
+  }
+
+  gst_query_parse_allocation (query, &caps, NULL);
+  if (!caps)
+    return FALSE;
+
+  gst_video_info_from_caps (&vinfo, caps);
+
+  n = gst_query_get_n_allocation_pools (query);
+  if (n > 0) {
+    update_pool = TRUE;
+    for (i = 0; i < n; i++) {
+      gst_query_parse_nth_allocation_pool (query, i, &pool, &size, &min, &max);
+
+      if (!pool || !GST_IS_GL_BUFFER_POOL (pool)) {
+        if (pool)
+          gst_object_unref (pool);
+        pool = NULL;
+      }
+    }
+  }
+
+  if (!pool) {
+    size = vinfo.size;
+    min = max = 0;
+    update_pool = FALSE;
+  }
+
+  if (!qt_src->context && !_find_local_gl_context (qt_src))
+    return FALSE;
+
+  if (!pool) {
+    if (!qt_src->context || !GST_IS_GL_CONTEXT (qt_src->context))
+      return FALSE;
+
+    pool = gst_gl_buffer_pool_new (qt_src->context);
+    GST_INFO_OBJECT (qt_src, "No pool, create one ourself %p", pool);
+  }
+
+  config = gst_buffer_pool_get_config (pool);
+
+  gst_buffer_pool_config_set_params (config, caps, size, min, max);
+  gst_buffer_pool_config_add_option (config, GST_BUFFER_POOL_OPTION_VIDEO_META);
+  if (gst_query_find_allocation_meta (query, GST_GL_SYNC_META_API_TYPE, NULL))
+    gst_buffer_pool_config_add_option (config,
+        GST_BUFFER_POOL_OPTION_GL_SYNC_META);
+
+  if (gst_query_get_n_allocation_params (query) > 0) {
+    gst_query_parse_nth_allocation_param (query, 0, &allocator, &params);
+    gst_buffer_pool_config_set_allocator (config, allocator, &params);
+    GST_INFO_OBJECT (qt_src, "got allocator %p", allocator);
+    update_allocator = TRUE;
+  } else {
+    allocator = NULL;
+    gst_allocation_params_init (&params);
+    update_allocator = FALSE;
+  }
+
+  glparams =
+      gst_gl_video_allocation_params_new (qt_src->context, &params, &vinfo, 0,
+      NULL, GST_GL_TEXTURE_TARGET_2D);
+  gst_buffer_pool_config_set_gl_allocation_params (config,
+      (GstGLAllocationParams *) glparams);
+  gst_gl_allocation_params_free ((GstGLAllocationParams *) glparams);
+
+  if (!gst_buffer_pool_set_config (pool, config))
+    GST_WARNING_OBJECT (qt_src, "Failed to set buffer pool config");
+
+  if (update_allocator)
+    gst_query_set_nth_allocation_param (query, 0, allocator, &params);
+  else
+    gst_query_add_allocation_param (query, allocator, &params);
+  if (allocator)
+    gst_object_unref (allocator);
+
+  if (update_pool)
+    gst_query_set_nth_allocation_pool (query, 0, pool, size, min, max);
+  else
+    gst_query_add_allocation_pool (query, pool, size, min, max);
+  gst_object_unref (pool);
+
+  GST_INFO_OBJECT (qt_src, "successfully decide_allocation");
+  return TRUE;
+}
+
+static GstFlowReturn
+gst_qt_src_fill (GstPushSrc * psrc, GstBuffer * buffer)
+{
+  GstQtSrc *qt_src = GST_QT_SRC (psrc);
+
+  GST_DEBUG_OBJECT (qt_src, "setting buffer %p", buffer);
+
+  if (!qt_window_set_buffer (qt_src->window, buffer)) {
+    GST_ERROR_OBJECT (qt_src, "failed to fill buffer %p", buffer);
+    return GST_FLOW_ERROR;
+  }
+
+  if (!qt_src->downstream_supports_affine_meta) {
+    if (qt_src->pending_image_orientation) {
+      /* let downstream know the image orientation is vertical filp */
+      GstTagList *image_orientation_tag =
+          gst_tag_list_new (GST_TAG_IMAGE_ORIENTATION, "flip-rotate-180", NULL);
+
+      gst_pad_push_event (GST_BASE_SRC_PAD (psrc),
+          gst_event_new_tag (image_orientation_tag));
+
+      qt_src->pending_image_orientation = FALSE;
+    }
+  } else {
+    GstVideoAffineTransformationMeta *trans_meta;
+    trans_meta = gst_buffer_add_video_affine_transformation_meta (buffer);
+    gst_video_affine_transformation_meta_apply_matrix (trans_meta,
+        vertical_flip_matrix);
+  }
+
+  GST_DEBUG_OBJECT (qt_src, "buffer fill done %p", buffer);
+
+  return GST_FLOW_OK;
+}
+
+static GstStateChangeReturn
+gst_qt_src_change_state (GstElement * element, GstStateChange transition)
+{
+  GstQtSrc *qt_src = GST_QT_SRC (element);
+  GstStateChangeReturn ret = GST_STATE_CHANGE_SUCCESS;
+  QGuiApplication *app;
+  guint64 frames_rendered = 0;
+
+  GST_DEBUG ("changing state: %s => %s",
+      gst_element_state_get_name (GST_STATE_TRANSITION_CURRENT (transition)),
+      gst_element_state_get_name (GST_STATE_TRANSITION_NEXT (transition)));
+
+  switch (transition) {
+    case GST_STATE_CHANGE_NULL_TO_READY:
+      app = static_cast < QGuiApplication * >(QCoreApplication::instance ());
+      if (!app) {
+        GST_ELEMENT_ERROR (element, RESOURCE, NOT_FOUND,
+            ("%s", "Failed to connect to Qt"),
+            ("%s", "Could not retrieve QGuiApplication instance"));
+        return GST_STATE_CHANGE_FAILURE;
+      }
+
+      if (!qt_src->window) {
+        GST_ELEMENT_ERROR (element, RESOURCE, NOT_FOUND,
+            ("%s", "Required property \'window\' not set"), (NULL));
+        return GST_STATE_CHANGE_FAILURE;
+      }
+
+      if (!qt_window_is_scenegraph_initialized (qt_src->window)) {
+        GST_ELEMENT_ERROR (element, RESOURCE, NOT_FOUND,
+            ("%s", "Could not initialize window system"), (NULL));
+        return GST_STATE_CHANGE_FAILURE;
+      }
+
+      qt_window_use_default_fbo (qt_src->window, qt_src->default_fbo);
+
+      break;
+    case GST_STATE_CHANGE_READY_TO_PAUSED:
+      break;
+    case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
+      break;
+    default:
+      break;
+  }
+
+  ret = GST_ELEMENT_CLASS (parent_class)->change_state (element, transition);
+  if (ret == GST_STATE_CHANGE_FAILURE)
+    return ret;
+
+  switch (transition) {
+    case GST_STATE_CHANGE_PLAYING_TO_PAUSED:
+      qt_src->run_time = gst_element_get_start_time (GST_ELEMENT (qt_src));
+      break;
+    case GST_STATE_CHANGE_PAUSED_TO_READY:
+      break;
+    case GST_STATE_CHANGE_READY_TO_NULL:
+      qt_window_get_total_frames (qt_src->window, &frames_rendered);
+      if (qt_src->run_time > 0) {
+        GST_DEBUG ("qmlglsrc Total refresh frames (%ld), playing for (%"
+            GST_TIME_FORMAT "), fps (%.3f).\n", frames_rendered,
+            GST_TIME_ARGS (qt_src->run_time),
+            (gfloat) GST_SECOND * frames_rendered / qt_src->run_time);
+      }
+      break;
+    default:
+      break;
+  }
+
+  return ret;
+}
+
+static gboolean
+gst_qt_src_start (GstBaseSrc * basesrc)
+{
+  GstQtSrc *qt_src = GST_QT_SRC (basesrc);
+
+  /* already has get OpenGL configuration from qt */
+  if (qt_src->display && qt_src->qt_context)
+    return TRUE;
+
+  if (!qt_window_is_scenegraph_initialized (qt_src->window))
+    return FALSE;
+
+  qt_src->display = qt_window_get_display (qt_src->window);
+  qt_src->qt_context = qt_window_get_qt_context (qt_src->window);
+
+  if (!qt_src->display || !qt_src->qt_context) {
+    GST_ERROR_OBJECT (qt_src,
+        "Could not retrieve window system OpenGL configuration");
+    return FALSE;
+  }
+
+  GST_DEBUG_OBJECT (qt_src, "Got qt display %p and qt gl context %p",
+      qt_src->display, qt_src->qt_context);
+  return TRUE;
+}
+
+static gboolean
+gst_qt_src_stop (GstBaseSrc * basesrc)
+{
+  return TRUE;
+}
diff --git a/ext/qt/gstqtsrc.h b/ext/qt/gstqtsrc.h
new file mode 100644
index 0000000..8bbf4e2
--- /dev/null
+++ b/ext/qt/gstqtsrc.h
@@ -0,0 +1,82 @@
+/*
+ * GStreamer
+ * Copyright (C) 2016 Freescale Semiconductor, Inc. All rights reserved.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef __GST_QT_SRC_H__
+#define __GST_QT_SRC_H__
+
+#include <gst/gst.h>
+#include <gst/base/gstpushsrc.h>
+#include <gst/video/video.h>
+#include <gst/gl/gl.h>
+#include "qtwindow.h"
+
+typedef struct _GstQtSrc GstQtSrc;
+typedef struct _GstQtSrcClass GstQtSrcClass;
+
+G_BEGIN_DECLS
+
+GType gst_qt_src_get_type (void);
+#define GST_TYPE_QT_SRC            (gst_qt_src_get_type())
+#define GST_QT_SRC(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_QT_SRC,GstQtSrc))
+#define GST_QT_SRC_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_QT_SRC,GstQtSrcClass))
+#define GST_IS_QT_SRC(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_QT_SRC))
+#define GST_IS_QT_SRC_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_QT_SRC))
+#define GST_QT_SRC_CAST(obj)       ((GstQtSrc*)(obj))
+
+/**
+ * GstQtSrc:
+ *
+ * Opaque #GstQtSrc object
+ */
+struct _GstQtSrc
+{
+  /* <private> */
+  GstPushSrc            parent;
+
+  QQuickWindow          *qwindow;
+  QtGLWindow            *window;
+
+  GstVideoInfo          v_info;
+
+  GstGLDisplay         *display;
+  GstGLContext         *context;
+  GstGLContext         *qt_context;
+
+  gboolean              default_fbo;
+  gboolean              downstream_supports_affine_meta;
+  gboolean              pending_image_orientation;
+  /* fps print support */
+  GstClockTime          run_time;
+};
+
+/**
+ * GstQtSrcClass:
+ *
+ * The #GstQtSrcClass struct only contains private data
+ */
+struct _GstQtSrcClass
+{
+  /* <private> */
+  GstPushSrcClass object_class;
+};
+
+G_END_DECLS
+
+#endif /* __GST_QT_SRC_H__ */
diff --git a/ext/qt/qtitem.cc b/ext/qt/qtitem.cc
index d48e470..16abf5f 100644
--- a/ext/qt/qtitem.cc
+++ b/ext/qt/qtitem.cc
@@ -27,37 +27,12 @@
 #include <gst/video/video.h>
 #include "qtitem.h"
 #include "gstqsgtexture.h"
+#include "gstqtglutility.h"
 
 #include <QtCore/QRunnable>
 #include <QtGui/QGuiApplication>
 #include <QtQuick/QQuickWindow>
 #include <QtQuick/QSGSimpleTextureNode>
-#include <qpa/qplatformnativeinterface.h>
-
-#if GST_GL_HAVE_WINDOW_X11 && GST_GL_HAVE_PLATFORM_GLX && defined (HAVE_QT_X11)
-#include <QX11Info>
-#include <gst/gl/x11/gstgldisplay_x11.h>
-#include <gst/gl/x11/gstglcontext_glx.h>
-#endif
-
-#if GST_GL_HAVE_WINDOW_WAYLAND && GST_GL_HAVE_PLATFORM_EGL && defined (HAVE_QT_WAYLAND)
-#include <gst/gl/wayland/gstgldisplay_wayland.h>
-#endif
-
-#if GST_GL_HAVE_WINDOW_ANDROID && GST_GL_HAVE_PLATFORM_EGL && defined (HAVE_QT_ANDROID)
-#include <gst/gl/egl/gstgldisplay_egl.h>
-#include <gst/gl/egl/gstglcontext_egl.h>
-#endif
-
-#if GST_GL_HAVE_WINDOW_COCOA && GST_GL_HAVE_PLATFORM_COCOA && defined (HAVE_QT_MAC)
-#include <gst/gl/coaoa/gstgldisplay_cocoa.h>
-#endif
-
-#if GST_GL_HAVE_WINDOW_FB
-#define LINUX
-#define EGL_API_FB
-#include <gst/gl/fb/gstgldisplay_fb.h>
-#endif
 
 /**
  * SECTION:gtkgstglwidget
@@ -129,11 +104,8 @@ void InitializeSceneGraph::run()
 
 QtGLVideoItem::QtGLVideoItem()
 {
-  QGuiApplication *app = static_cast<QGuiApplication *> (QCoreApplication::instance ());
   static volatile gsize _debug;
 
-  g_assert (app != NULL);
-
   if (g_once_init_enter (&_debug)) {
     GST_DEBUG_CATEGORY_INIT (GST_CAT_DEFAULT, "qtglwidget", 0, "Qt GL Widget");
     g_once_init_leave (&_debug, 1);
@@ -149,38 +121,7 @@ QtGLVideoItem::QtGLVideoItem()
 
   g_mutex_init (&this->priv->lock);
 
-#if GST_GL_HAVE_WINDOW_X11 && defined (HAVE_QT_X11)
-  if (QString::fromUtf8 ("xcb") == app->platformName())
-    this->priv->display = (GstGLDisplay *)
-        gst_gl_display_x11_new_with_display (QX11Info::display ());
-#endif
-#if GST_GL_HAVE_WINDOW_WAYLAND && GST_GL_HAVE_PLATFORM_EGL && defined (HAVE_QT_WAYLAND)
-  if (QString::fromUtf8 ("wayland") == app->platformName()
-      || QString::fromUtf8 ("wayland-egl") == app->platformName()){
-    struct wl_display * wayland_display;
-    QPlatformNativeInterface *native =
-        QGuiApplication::platformNativeInterface();
-    wayland_display = (struct wl_display *)
-        native->nativeResourceForWindow("display", NULL);
-    this->priv->display = (GstGLDisplay *)
-        gst_gl_display_wayland_new_with_display (wayland_display);
-  }
-#endif
-#if GST_GL_HAVE_WINDOW_ANDROID && GST_GL_HAVE_PLATFORM_EGL && defined (HAVE_QT_ANDROID)
-  if (QString::fromUtf8 ("android") == app->platformName())
-    this->priv->display = (GstGLDisplay *) gst_gl_display_egl_new ();
-#endif
-#if GST_GL_HAVE_WINDOW_COCOA && GST_GL_HAVE_PLATFORM_COCOA && defined (HAVE_QT_MAC)
-  if (QString::fromUtf8 ("cocoa") == app->platformName())
-    this->priv->display = (GstGLDisplay *) gst_gl_display_cocoa_new ();
-#endif
-#if GST_GL_HAVE_WINDOW_EAGL && GST_GL_HAVE_PLATFORM_EAGL && defined (HAVE_QT_IOS)
-  if (QString::fromUtf8 ("ios") == app->platformName())
-    this->priv->display = gst_gl_display_new ();
-#endif
-
-  if (!this->priv->display)
-    this->priv->display = gst_gl_display_new ();
+  this->priv->display = gst_qt_get_gl_display();
 
   connect(this, SIGNAL(windowChanged(QQuickWindow*)), this,
           SLOT(handleWindowChanged(QQuickWindow*)));
@@ -314,10 +255,6 @@ qt_item_set_buffer (QtGLVideoItem * widget, GstBuffer * buffer)
 void
 QtGLVideoItem::onSceneGraphInitialized ()
 {
-  GstGLPlatform platform;
-  GstGLAPI gl_api;
-  guintptr gl_handle;
-
   GST_DEBUG ("scene graph initialization with Qt GL context %p",
       this->window()->openglContext ());
 
@@ -330,91 +267,8 @@ QtGLVideoItem::onSceneGraphInitialized ()
     return;
   }
 
-#if GST_GL_HAVE_WINDOW_X11 && defined (HAVE_QT_X11)
-  if (GST_IS_GL_DISPLAY_X11 (this->priv->display)) {
-    platform = GST_GL_PLATFORM_GLX;
-    gl_api = gst_gl_context_get_current_gl_api (platform, NULL, NULL);
-    gl_handle = gst_gl_context_get_current_gl_context (platform);
-    if (gl_handle)
-      this->priv->other_context =
-          gst_gl_context_new_wrapped (this->priv->display, gl_handle,
-          platform, gl_api);
-  }
-#endif
-#if GST_GL_HAVE_WINDOW_WAYLAND && defined (HAVE_QT_WAYLAND)
-  if (GST_IS_GL_DISPLAY_WAYLAND (this->priv->display)) {
-    platform = GST_GL_PLATFORM_EGL;
-    gl_api = gst_gl_context_get_current_gl_api (platform, NULL, NULL);
-    gl_handle = gst_gl_context_get_current_gl_context (platform);
-    if (gl_handle)
-      this->priv->other_context =
-          gst_gl_context_new_wrapped (this->priv->display, gl_handle,
-          platform, gl_api);
-  }
-#endif
-#if GST_GL_HAVE_WINDOW_ANDROID && GST_GL_HAVE_PLATFORM_EGL && defined (HAVE_QT_ANDROID)
-  if (GST_IS_GL_DISPLAY_EGL (this->priv->display)) {
-    platform = GST_GL_PLATFORM_EGL;
-    gl_api = gst_gl_context_get_current_gl_api (platform, NULL, NULL);
-    gl_handle = gst_gl_context_get_current_gl_context (platform);
-    if (gl_handle)
-      this->priv->other_context =
-          gst_gl_context_new_wrapped (this->priv->display, gl_handle,
-          platform, gl_api);
-  }
-#endif
-#if GST_GL_HAVE_WINDOW_COCOA && GST_GL_HAVE_PLATFORM_COCOA && defined (HAVE_QT_MAC)
-  if (this->priv->display) {
-    platform = GST_GL_PLATFORM_CGL;
-    gl_api = gst_gl_context_get_current_gl_api (platform, NULL, NULL);
-    gl_handle = gst_gl_context_get_current_gl_context (platform);
-    if (gl_handle)
-      this->priv->other_context =
-          gst_gl_context_new_wrapped (this->priv->display, gl_handle,
-          platform, gl_api);
-  }
-#endif
-#if GST_GL_HAVE_WINDOW_EAGL && GST_GL_HAVE_PLATFORM_EAGL && defined (HAVE_QT_IOS)
-  if (this->priv->display) {
-    platform = GST_GL_PLATFORM_EAGL;
-    gl_api = gst_gl_context_get_current_gl_api (platform, NULL, NULL);
-    gl_handle = gst_gl_context_get_current_gl_context (platform);
-    if (gl_handle)
-      this->priv->other_context =
-          gst_gl_context_new_wrapped (this->priv->display, gl_handle,
-          platform, gl_api);
-  }
-#endif
-#if GST_GL_HAVE_WINDOW_FB
-  if (GST_IS_GL_DISPLAY_FB (this->priv->display)) {
-    platform = GST_GL_PLATFORM_EGL;
-    gl_api = gst_gl_context_get_current_gl_api (platform, NULL, NULL);
-    gl_handle = gst_gl_context_get_current_gl_context (platform);
-    if (gl_handle)
-      this->priv->other_context =
-          gst_gl_context_new_wrapped (this->priv->display, gl_handle,
-          platform, gl_api);
-  }
-#endif
-
-  (void) platform;
-  (void) gl_api;
-  (void) gl_handle;
-
-  if (this->priv->other_context) {
-    GError *error = NULL;
-
-    gst_gl_context_activate (this->priv->other_context, TRUE);
-    if (!gst_gl_context_fill_info (this->priv->other_context, &error)) {
-      GST_ERROR ("%p failed to retrieve qt context info: %s", this, error->message);
-      g_object_unref (this->priv->other_context);
-      this->priv->other_context = NULL;
-    } else {
-      gst_gl_display_filter_gl_api (this->priv->display, gst_gl_context_get_gl_api (this->priv->other_context));
-      gst_gl_context_activate (this->priv->other_context, FALSE);
-      m_openGlContextInitialized = true;
-    }
-  }
+  m_openGlContextInitialized = gst_qt_get_gl_wrapcontext (this->priv->display,
+      &this->priv->other_context, &this->priv->context);
 
   GST_DEBUG ("%p created wrapped GL context %" GST_PTR_FORMAT, this,
       this->priv->other_context);
diff --git a/ext/qt/qtwindow.cc b/ext/qt/qtwindow.cc
new file mode 100644
index 0000000..4702891
--- /dev/null
+++ b/ext/qt/qtwindow.cc
@@ -0,0 +1,371 @@
+/*
+ * GStreamer
+ * Copyright (C) 2016 Freescale Semiconductor, Inc. All rights reserved.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdio.h>
+
+#include <gst/video/video.h>
+#include "qtwindow.h"
+#include "gstqsgtexture.h"
+#include "gstqtglutility.h"
+
+#include <QtCore/QRunnable>
+#include <QtGui/QGuiApplication>
+#include <QtQuick/QQuickWindow>
+#include <QOpenGLFramebufferObject>
+
+/**
+ * SECTION:
+ *
+ * #QtGLWindow is an #QQuickWindow that grab QtQuick view to GStreamer OpenGL video buffers.
+ */
+
+GST_DEBUG_CATEGORY_STATIC (qt_window_debug);
+#define GST_CAT_DEFAULT qt_window_debug
+
+struct _QtGLWindowPrivate
+{
+  GMutex lock;
+  GCond update_cond;
+
+  GstBuffer *buffer;
+  GstCaps *caps;
+  GstVideoInfo v_info;
+
+  gboolean initted;
+  gboolean updated;
+  gboolean quit;
+  gboolean result;
+  gboolean useDefaultFbo;
+
+  GstGLDisplay *display;
+  GstGLContext *other_context;
+
+  /* frames that qmlview rendered in its gl thread */
+  guint64 frames_rendered;
+};
+
+class InitQtGLContext : public QRunnable
+{
+public:
+  InitQtGLContext(QtGLWindow *window);
+  void run();
+
+private:
+  QtGLWindow *window_;
+};
+
+InitQtGLContext::InitQtGLContext(QtGLWindow *window) :
+  window_(window)
+{
+}
+
+void InitQtGLContext::run()
+{
+  window_->onSceneGraphInitialized();
+}
+
+QtGLWindow::QtGLWindow ( QWindow * parent, QQuickWindow *src ) :
+  QQuickWindow( parent ), source (src)
+{
+  QGuiApplication *app = static_cast<QGuiApplication *> (QCoreApplication::instance ());
+  static volatile gsize _debug;
+
+  g_assert (app != NULL);
+
+  if (g_once_init_enter (&_debug)) {
+    GST_DEBUG_CATEGORY_INIT (GST_CAT_DEFAULT, "qtglwindow", 0, "Qt GL QuickWindow");
+    g_once_init_leave (&_debug, 1);
+  }
+
+  this->priv = g_new0 (QtGLWindowPrivate, 1);
+
+  g_mutex_init (&this->priv->lock);
+  g_cond_init (&this->priv->update_cond);
+
+  this->priv->display = gst_qt_get_gl_display();
+
+  connect (source, SIGNAL(beforeRendering()), this, SLOT(beforeRendering()), Qt::DirectConnection);
+  connect (source, SIGNAL(afterRendering()), this, SLOT(afterRendering()), Qt::DirectConnection);
+  connect (app, SIGNAL(aboutToQuit()), this, SLOT(aboutToQuit()), Qt::DirectConnection);
+  if (source->isSceneGraphInitialized())
+    source->scheduleRenderJob(new InitQtGLContext(this), QQuickWindow::BeforeSynchronizingStage);
+  else
+    connect (source, SIGNAL(sceneGraphInitialized()), this, SLOT(onSceneGraphInitialized()), Qt::DirectConnection);
+
+  GST_DEBUG ("%p init Qt Window", this->priv->display);
+}
+
+QtGLWindow::~QtGLWindow()
+{
+  GST_DEBUG ("deinit Qt Window");
+  g_mutex_clear (&this->priv->lock);
+  g_cond_clear (&this->priv->update_cond);
+  if (this->priv->other_context)
+    gst_object_unref(this->priv->other_context);
+  if (this->priv->display)
+    gst_object_unref(this->priv->display);
+  g_free (this->priv);
+  this->priv = NULL;
+}
+
+void
+QtGLWindow::beforeRendering()
+{
+  unsigned int width, height;
+
+  g_mutex_lock (&this->priv->lock);
+
+  if (!fbo && !this->priv->useDefaultFbo) {
+
+    width = source->width();
+    height = source->height();
+
+    GST_DEBUG ("create new framebuffer object %dX%d", width, height);
+
+    fbo.reset(new QOpenGLFramebufferObject (width, height,
+          QOpenGLFramebufferObject::NoAttachment, GL_TEXTURE_2D, GL_RGBA));
+
+    source->setRenderTarget(fbo.data());
+  }
+
+  g_mutex_unlock (&this->priv->lock);
+}
+
+
+void
+QtGLWindow::afterRendering()
+{
+  GstVideoFrame gl_frame;
+  GstVideoInfo *info;
+  GstGLContext *context;
+  gboolean ret;
+  guint width, height;
+  const GstGLFuncs *gl;
+  GLuint dst_tex;
+
+  g_mutex_lock (&this->priv->lock);
+
+  this->priv->frames_rendered++;
+
+  if(!this->priv->buffer || this->priv->updated == TRUE) {
+    GST_DEBUG ("skip this frame");
+    g_mutex_unlock (&this->priv->lock);
+    return;
+  }
+
+  GST_DEBUG ("copy buffer %p",this->priv->buffer);
+
+  width = GST_VIDEO_INFO_WIDTH (&this->priv->v_info);
+  height = GST_VIDEO_INFO_HEIGHT (&this->priv->v_info);
+  info = &this->priv->v_info;
+  context = this->priv->other_context;
+
+  gst_gl_context_activate (context, TRUE);
+  gl = context->gl_vtable;
+
+  ret = gst_video_frame_map (&gl_frame, info, this->priv->buffer,
+      (GstMapFlags) (GST_MAP_WRITE | GST_MAP_GL));
+
+  if (!ret) {
+    this->priv->buffer = NULL;
+    GST_ERROR ("Failed to map video frame");
+    goto errors;
+  }
+
+  gl->BindFramebuffer (GL_READ_FRAMEBUFFER, this->source->renderTargetId());
+
+  ret = gst_gl_context_check_framebuffer_status (context);
+  if (!ret) {
+    GST_ERROR ("FBO errors");
+    goto errors;
+  }
+
+  dst_tex = *(guint *) gl_frame.data[0];
+  GST_DEBUG ("qml render target id %d, render to tex %d %dX%d", 
+      this->source->renderTargetId(), dst_tex, width,height);
+
+  gl->BindTexture (GL_TEXTURE_2D, dst_tex);
+  gl->CopyTexImage2D (GL_TEXTURE_2D, 0, GL_RGBA, 0, 0, width, height, 0);
+  
+  GST_DEBUG ("rendering finished");
+
+errors:
+  gl->BindFramebuffer (GL_FRAMEBUFFER, 0);
+  gst_video_frame_unmap (&gl_frame);
+
+  gst_gl_context_activate (context, FALSE);
+
+  this->priv->result = ret;
+  this->priv->updated = TRUE;
+  g_cond_signal (&this->priv->update_cond);
+  g_mutex_unlock (&this->priv->lock);
+}
+
+void
+QtGLWindow::aboutToQuit()
+{
+  g_mutex_lock (&this->priv->lock);
+
+  this->priv->updated = TRUE;
+  this->priv->quit = TRUE;
+  g_cond_signal (&this->priv->update_cond);
+
+  g_mutex_unlock (&this->priv->lock);
+
+  GST_DEBUG("about to quit");
+}
+
+void
+QtGLWindow::onSceneGraphInitialized()
+{
+  GST_DEBUG ("scene graph initialization with Qt GL context %p",
+      this->source->openglContext ());
+
+  this->priv->initted = gst_qt_get_gl_wrapcontext (this->priv->display,
+      &this->priv->other_context, NULL);
+
+  GST_DEBUG ("%p created wrapped GL context %" GST_PTR_FORMAT, this,
+      this->priv->other_context);
+}
+
+bool
+QtGLWindow::getGeometry(int * width, int * height)
+{
+  if (width == NULL || height == NULL)
+    return FALSE;
+
+  *width = this->source->width();
+  *height = this->source->height();
+
+  return TRUE;
+}
+
+GstGLContext *
+qt_window_get_qt_context (QtGLWindow * qt_window)
+{
+  g_return_val_if_fail (qt_window != NULL, NULL);
+
+  if (!qt_window->priv->other_context)
+    return NULL;
+
+  return (GstGLContext *) gst_object_ref (qt_window->priv->other_context);
+}
+
+GstGLDisplay *
+qt_window_get_display (QtGLWindow * qt_window)
+{
+  g_return_val_if_fail (qt_window != NULL, NULL);
+
+  if (!qt_window->priv->display)
+    return NULL;
+
+  return (GstGLDisplay *) gst_object_ref (qt_window->priv->display);
+}
+
+gboolean
+qt_window_is_scenegraph_initialized (QtGLWindow * qt_window)
+{
+  g_return_val_if_fail (qt_window != NULL, FALSE);
+
+  return qt_window->priv->initted;
+}
+
+gboolean
+qt_window_set_caps (QtGLWindow * qt_window, GstCaps * caps)
+{
+  GstVideoInfo v_info;
+
+  g_return_val_if_fail (qt_window != NULL, FALSE);
+  g_return_val_if_fail (GST_IS_CAPS (caps), FALSE);
+  g_return_val_if_fail (gst_caps_is_fixed (caps), FALSE);
+
+  if (qt_window->priv->caps && gst_caps_is_equal_fixed (qt_window->priv->caps, caps))
+    return TRUE;
+
+  if (!gst_video_info_from_caps (&v_info, caps))
+    return FALSE;
+
+  g_mutex_lock (&qt_window->priv->lock);
+
+  gst_caps_replace (&qt_window->priv->caps, caps);
+
+  qt_window->priv->v_info = v_info;
+
+  g_mutex_unlock (&qt_window->priv->lock);
+
+  return TRUE;
+}
+
+gboolean
+qt_window_set_buffer (QtGLWindow * qt_window, GstBuffer * buffer)
+{
+  g_return_val_if_fail (qt_window != NULL, FALSE);
+  g_return_val_if_fail (qt_window->priv->initted, FALSE);
+  gboolean ret;
+
+  g_mutex_lock (&qt_window->priv->lock);
+
+  if (qt_window->priv->quit){
+    GST_DEBUG("about to quit, drop this buffer");
+    g_mutex_unlock (&qt_window->priv->lock);
+    return TRUE;
+  }
+
+  qt_window->priv->updated = FALSE;
+  qt_window->priv->buffer = buffer;
+
+  while (!qt_window->priv->updated) 
+    g_cond_wait (&qt_window->priv->update_cond, &qt_window->priv->lock);
+  
+  ret = qt_window->priv->result;
+
+  g_mutex_unlock (&qt_window->priv->lock);
+
+  return ret;
+}
+
+void
+qt_window_use_default_fbo (QtGLWindow * qt_window, gboolean useDefaultFbo)
+{
+  g_return_if_fail (qt_window != NULL);
+
+  g_mutex_lock (&qt_window->priv->lock);
+
+  GST_DEBUG ("set to use default fbo %d", useDefaultFbo);
+  qt_window->priv->useDefaultFbo = useDefaultFbo;
+
+  g_mutex_unlock (&qt_window->priv->lock);
+}
+
+void
+qt_window_get_total_frames (QtGLWindow * qt_window, guint64 *frames)
+{
+  g_return_if_fail (qt_window != NULL);
+
+  g_mutex_lock (&qt_window->priv->lock);
+
+  *frames = qt_window->priv->frames_rendered;
+
+  g_mutex_unlock (&qt_window->priv->lock);
+}
diff --git a/ext/qt/qtwindow.h b/ext/qt/qtwindow.h
new file mode 100644
index 0000000..5820e77
--- /dev/null
+++ b/ext/qt/qtwindow.h
@@ -0,0 +1,70 @@
+/*
+ * GStreamer
+ * Copyright (C) 2016 Freescale Semiconductor, Inc. All rights reserved.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef __QT_WINDOW_H__
+#define __QT_WINDOW_H__
+
+#include <gst/gst.h>
+#include <gst/gl/gl.h>
+
+#include "gstqtgl.h"
+#include <QtQuick/QQuickWindow>
+#include <QtGui/QOpenGLContext>
+#include <QtGui/QOpenGLFunctions>
+
+typedef struct _QtGLWindowPrivate QtGLWindowPrivate;
+
+class InitQtGLContext;
+
+class QtGLWindow : public QQuickWindow, protected QOpenGLFunctions
+{
+    Q_OBJECT
+public:
+    QtGLWindow (QWindow * parent = NULL, QQuickWindow *source = NULL);
+    ~QtGLWindow ();
+    bool getGeometry (int * width, int * height);
+
+    /* private for C interface ... */
+    QtGLWindowPrivate *priv;
+
+private Q_SLOTS:
+    void beforeRendering ();
+    void afterRendering ();
+    void onSceneGraphInitialized ();
+    void aboutToQuit();
+
+private:
+    friend class InitQtGLContext;
+    QQuickWindow * source;
+    QScopedPointer<QOpenGLFramebufferObject> fbo;
+};
+
+extern "C"
+{
+gboolean        qt_window_set_buffer (QtGLWindow * qt_window, GstBuffer * buffer);
+gboolean        qt_window_set_caps (QtGLWindow * qt_window, GstCaps * caps);
+GstGLContext *  qt_window_get_qt_context (QtGLWindow * qt_window);
+GstGLDisplay *  qt_window_get_display (QtGLWindow * qt_window);
+gboolean        qt_window_is_scenegraph_initialized (QtGLWindow * qt_window);
+void            qt_window_use_default_fbo (QtGLWindow * qt_window, gboolean useDefaultFbo);
+void            qt_window_get_total_frames (QtGLWindow * qt_window, guint64 *frames);
+}
+
+#endif /* __QT_WINDOW_H__ */
-- 
1.9.1

