From f66eda75d44111fb35c44b7b5d190f6179023d6b Mon Sep 17 00:00:00 2001
From: Prabhu Sundararaj <prabhu.sundararaj@freescale.com>
Date: Thu, 21 Nov 2013 18:12:32 -0600
Subject: [PATCH 2/2] ENGR00288957-2 : Add Support for Wayland 1.3

Add support for i.MX6 SOC with 2D renderer(GAL2D renderer)

Signed-off-by: Prabhu Sundararaj <prabhu.sundararaj@freescale.com>
---
 src/Makefile.am        |    4 +-
 src/compositor-fbdev.c |   82 ++-
 src/gal2d-renderer.c   | 1429 ++++++++++++++++++++++++++++++++++++++++++++++++
 src/gal2d-renderer.h   |   41 ++
 4 files changed, 1546 insertions(+), 10 deletions(-)
 create mode 100644 src/gal2d-renderer.c
 create mode 100644 src/gal2d-renderer.h

diff --git a/src/Makefile.am b/src/Makefile.am
index 749c074..8a70e7f 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -230,7 +230,9 @@ fbdev_backend_la_SOURCES = \
 	evdev.h \
 	evdev-touchpad.c \
 	launcher-util.c \
-	launcher-util.h
+	launcher-util.h \
+	gal2d-renderer.h \
+	gal2d-renderer.c
 endif
 
 if ENABLE_RDP_COMPOSITOR
diff --git a/src/compositor-fbdev.c b/src/compositor-fbdev.c
index 5114295..81a5b00 100644
--- a/src/compositor-fbdev.c
+++ b/src/compositor-fbdev.c
@@ -44,6 +44,7 @@
 #include "pixman-renderer.h"
 #include "udev-seat.h"
 #include "gl-renderer.h"
+#include "gal2d-renderer.h"
 
 struct fbdev_compositor {
 	struct weston_compositor base;
@@ -52,6 +53,7 @@ struct fbdev_compositor {
 	struct udev *udev;
 	struct udev_input input;
 	int use_pixman;
+	int use_gal2d;
 	struct wl_listener session_listener;
 	NativeDisplayType display;
 };
@@ -88,6 +90,8 @@ struct fbdev_output {
 	pixman_image_t *shadow_surface;
 	void *shadow_buf;
 	uint8_t depth;
+
+	NativeDisplayType display;
 	NativeWindowType  window;
 };
 
@@ -95,6 +99,7 @@ struct fbdev_parameters {
 	int tty;
 	char *device;
 	int use_gl;
+	int use_gal2d;
 };
 
 static const char default_seat[] = "seat0";
@@ -498,7 +503,7 @@ static void fbdev_output_disable(struct weston_output *base);
 
 static int
 fbdev_output_create(struct fbdev_compositor *compositor,
-                    const char *device)
+                   int x, int y, const char *device)
 {
 	struct fbdev_output *output;
 	pixman_transform_t transform;
@@ -508,7 +513,7 @@ fbdev_output_create(struct fbdev_compositor *compositor,
 	unsigned int bytes_per_pixel;
 	struct wl_event_loop *loop;
 
-	weston_log("Creating fbdev output.\n");
+	weston_log("Creating fbdev output. %s x=%d\n", device, x);
 
 	output = calloc(1, sizeof *output);
 	if (!output)
@@ -555,7 +560,7 @@ fbdev_output_create(struct fbdev_compositor *compositor,
 	output->base.model = output->fb_info.id;
 
 	weston_output_init(&output->base, &compositor->base,
-	                   0, 0, output->fb_info.width_mm,
+	                   x, y, output->fb_info.width_mm,
 	                   output->fb_info.height_mm,
 	                   WL_OUTPUT_TRANSFORM_NORMAL,
 			   1);
@@ -625,7 +630,29 @@ fbdev_output_create(struct fbdev_compositor *compositor,
 	if (compositor->use_pixman) {
 		if (pixman_renderer_output_create(&output->base) < 0)
 			goto out_shadow_surface;
-	} else {
+	} else if(compositor->use_gal2d) {
+		char* fbenv = getenv("FB_FRAMEBUFFER_0");
+		setenv("FB_FRAMEBUFFER_0", device, 1);
+		output->display = fbGetDisplay(compositor->base.wl_display);
+	    if (output->display == NULL) {
+	       fprintf(stderr, "failed to get display\n");
+	       return 0;
+	    }
+	    output->window = fbCreateWindow(output->display, -1, -1, 0, 0);
+	    if (output->window == NULL) {
+	       fprintf(stderr, "failed to create window\n");
+	       return 0;
+	    }
+	    setenv("FB_FRAMEBUFFER_0", fbenv, 1);
+		
+		if (gal2d_renderer_output_create(&output->base,
+					output->display,
+					(EGLNativeWindowType)output->window) < 0) {
+			weston_log("gal_renderer_output_create failed.\n");
+			goto out_shadow_surface;
+		}
+	}
+	else {
 		output->window = fbCreateWindow(compositor->display, -1, -1, 0, 0);
 	    if (output->window == NULL) {
 	       fprintf(stderr, "failed to create window\n");
@@ -757,7 +784,7 @@ fbdev_output_reenable(struct fbdev_compositor *compositor,
 		 * are re-initialised. */
 		device = output->device;
 		fbdev_output_destroy(base);
-		fbdev_output_create(compositor, device);
+		fbdev_output_create(compositor, 0, 0, device);
 
 		return 0;
 	}
@@ -914,7 +941,11 @@ fbdev_compositor_create(struct wl_display *display, int *argc, char *argv[],
 
 	compositor->base.focus = 1;
 	compositor->prev_state = WESTON_COMPOSITOR_ACTIVE;
-	compositor->use_pixman = !param->use_gl;
+
+	compositor->use_gal2d = param->use_gal2d;
+	weston_log("compositor->use_gal2d=%d\n", compositor->use_gal2d);
+	if(param->use_gl == 0 && param->use_gal2d == 0)
+		compositor->use_pixman = 1;
 
 	for (key = KEY_F1; key < KEY_F9; key++)
 		weston_compositor_add_key_binding(&compositor->base, key,
@@ -924,7 +955,11 @@ fbdev_compositor_create(struct wl_display *display, int *argc, char *argv[],
 	if (compositor->use_pixman) {
 		if (pixman_renderer_init(&compositor->base) < 0)
 			goto out_launcher;
-	} else {
+	} else if(compositor->use_gal2d){
+		if (gal2d_renderer_create(&compositor->base) < 0)
+			goto out_launcher;
+	}
+	else {
 		compositor->display = fbGetDisplay(compositor->base.wl_display);
 	    if (compositor->display == NULL) {
 			weston_log("fbGetDisplay failed.\n");
@@ -936,8 +971,35 @@ fbdev_compositor_create(struct wl_display *display, int *argc, char *argv[],
 			goto out_launcher;
 		}
 	}
-
-	if (fbdev_output_create(compositor, param->device) < 0)
+	if(compositor->use_gal2d){
+		int x = 0, y = 0;
+		int i=0;
+		int count = strlen(param->device);
+		int k=0, dispCount = 0;
+		char displays[5][32];
+		weston_log("param->device=%s\n",param->device);
+		for(i= 0; i < count; i++) {
+			if(param->device[i] == ',')	{
+				displays[dispCount][k] = '\0';
+				dispCount++;
+				k = 0;
+				continue;
+			}
+			displays[dispCount][k++] = param->device[i];
+		}
+		displays[dispCount][k] = '\0';
+		dispCount++;
+
+		for(i=0; i<dispCount; i++)
+		{
+			if (fbdev_output_create(compositor, x, y, displays[i]) < 0)
+				goto out_pixman;
+			x += container_of(compositor->base.output_list.prev,
+								  struct weston_output,
+								  link)->width;
+		}
+	}
+	else if (fbdev_output_create(compositor, 0, 0, param->device) < 0)
 		goto out_pixman;
 
 	udev_input_init(&compositor->input, &compositor->base, compositor->udev, seat_id);
@@ -972,12 +1034,14 @@ backend_init(struct wl_display *display, int *argc, char *argv[],
 		.tty = 0, /* default to current tty */
 		.device = "/dev/fb0", /* default frame buffer */
 		.use_gl = 0,
+		.use_gal2d = 1,
 	};
 
 	const struct weston_option fbdev_options[] = {
 		{ WESTON_OPTION_INTEGER, "tty", 0, &param.tty },
 		{ WESTON_OPTION_STRING, "device", 0, &param.device },
 		{ WESTON_OPTION_BOOLEAN, "use-gl", 0, &param.use_gl },
+		{ WESTON_OPTION_BOOLEAN, "use-gal2d", 0, &param.use_gal2d },
 	};
 
 	parse_options(fbdev_options, ARRAY_LENGTH(fbdev_options), argc, argv);
diff --git a/src/gal2d-renderer.c b/src/gal2d-renderer.c
new file mode 100644
index 0000000..71f510d
--- /dev/null
+++ b/src/gal2d-renderer.c
@@ -0,0 +1,1429 @@
+/*
+ * Copyright Â© 2012 Intel Corporation
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and
+ * its documentation for any purpose is hereby granted without fee, provided
+ * that the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of the copyright holders not be used in
+ * advertising or publicity pertaining to distribution of the software
+ * without specific, written prior permission.  The copyright holders make
+ * no representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
+ * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#define _GNU_SOURCE
+
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <float.h>
+#include <assert.h>
+#include "compositor.h"
+#include "gal2d-renderer.h"
+#include "HAL/gc_hal.h"
+#include "HAL/gc_hal_raster.h"
+#include "HAL/gc_hal_eglplatform.h"
+
+#define galONERROR(x)  if(status < 0) printf("Error in function %s\n", __func__);
+
+
+struct gal2d_output_state {
+	
+	int current_buffer;
+	pixman_region32_t buffer_damage[2];
+	EGLNativeDisplayType display;
+    gcoSURF* renderSurf;
+	gctUINT32 nNumBuffers;
+	int activebuffer;
+	gcoSURF offscreenSurface;
+	gceSURF_FORMAT format;
+	gcoSURF tempSurf;
+};
+
+struct gal2d_surface_state {
+	float color[4];
+	struct weston_buffer_reference buffer_ref;
+	int pitch; /* in pixels */
+    pixman_region32_t texture_damage;
+    gcoSURF gco_Surface;
+};
+
+struct gal2d_renderer {
+	struct weston_renderer base;
+    
+    gcoOS gcos;
+	gcoHAL gcoHal;
+	gco2D gcoEngine2d;
+    gctPOINTER  localInfo;
+};
+
+struct polygon8 {
+	float x[8];
+	float y[8];
+	int n;
+};
+
+struct clip_context {
+	struct {
+		float x;
+		float y;
+	} prev;
+
+	struct {
+		float x1, y1;
+		float x2, y2;
+	} clip;
+
+	struct {
+		float *x;
+		float *y;
+	} vertices;
+};
+
+static float
+float_difference(float a, float b)
+{
+	/* http://www.altdevblogaday.com/2012/02/22/comparing-floating-point-numbers-2012-edition/ */
+	static const float max_diff = 4.0f * FLT_MIN;
+	static const float max_rel_diff = 4.0e-5;
+	float diff = a - b;
+	float adiff = fabsf(diff);
+
+	if (adiff <= max_diff)
+		return 0.0f;
+
+	a = fabsf(a);
+	b = fabsf(b);
+	if (adiff <= (a > b ? a : b) * max_rel_diff)
+		return 0.0f;
+
+	return diff;
+}
+
+/* A line segment (p1x, p1y)-(p2x, p2y) intersects the line x = x_arg.
+ * Compute the y coordinate of the intersection.
+ */
+static float
+clip_intersect_y(float p1x, float p1y, float p2x, float p2y,
+		 float x_arg)
+{
+	float a;
+	float diff = float_difference(p1x, p2x);
+
+	/* Practically vertical line segment, yet the end points have already
+	 * been determined to be on different sides of the line. Therefore
+	 * the line segment is part of the line and intersects everywhere.
+	 * Return the end point, so we use the whole line segment.
+	 */
+	if (diff == 0.0f)
+		return p2y;
+
+	a = (x_arg - p2x) / diff;
+	return p2y + (p1y - p2y) * a;
+}
+
+/* A line segment (p1x, p1y)-(p2x, p2y) intersects the line y = y_arg.
+ * Compute the x coordinate of the intersection.
+ */
+static float
+clip_intersect_x(float p1x, float p1y, float p2x, float p2y,
+		 float y_arg)
+{
+	float a;
+	float diff = float_difference(p1y, p2y);
+
+	/* Practically horizontal line segment, yet the end points have already
+	 * been determined to be on different sides of the line. Therefore
+	 * the line segment is part of the line and intersects everywhere.
+	 * Return the end point, so we use the whole line segment.
+	 */
+	if (diff == 0.0f)
+		return p2x;
+
+	a = (y_arg - p2y) / diff;
+	return p2x + (p1x - p2x) * a;
+}
+
+enum path_transition {
+	PATH_TRANSITION_OUT_TO_OUT = 0,
+	PATH_TRANSITION_OUT_TO_IN = 1,
+	PATH_TRANSITION_IN_TO_OUT = 2,
+	PATH_TRANSITION_IN_TO_IN = 3,
+};
+
+static void
+clip_append_vertex(struct clip_context *ctx, float x, float y)
+{
+	*ctx->vertices.x++ = x;
+	*ctx->vertices.y++ = y;
+}
+
+static enum path_transition
+path_transition_left_edge(struct clip_context *ctx, float x, float y)
+{
+	return ((ctx->prev.x >= ctx->clip.x1) << 1) | (x >= ctx->clip.x1);
+}
+
+static enum path_transition
+path_transition_right_edge(struct clip_context *ctx, float x, float y)
+{
+	return ((ctx->prev.x < ctx->clip.x2) << 1) | (x < ctx->clip.x2);
+}
+
+static enum path_transition
+path_transition_top_edge(struct clip_context *ctx, float x, float y)
+{
+	return ((ctx->prev.y >= ctx->clip.y1) << 1) | (y >= ctx->clip.y1);
+}
+
+static enum path_transition
+path_transition_bottom_edge(struct clip_context *ctx, float x, float y)
+{
+	return ((ctx->prev.y < ctx->clip.y2) << 1) | (y < ctx->clip.y2);
+}
+
+static void
+clip_polygon_leftright(struct clip_context *ctx,
+		       enum path_transition transition,
+		       float x, float y, float clip_x)
+{
+	float yi;
+
+	switch (transition) {
+	case PATH_TRANSITION_IN_TO_IN:
+		clip_append_vertex(ctx, x, y);
+		break;
+	case PATH_TRANSITION_IN_TO_OUT:
+		yi = clip_intersect_y(ctx->prev.x, ctx->prev.y, x, y, clip_x);
+		clip_append_vertex(ctx, clip_x, yi);
+		break;
+	case PATH_TRANSITION_OUT_TO_IN:
+		yi = clip_intersect_y(ctx->prev.x, ctx->prev.y, x, y, clip_x);
+		clip_append_vertex(ctx, clip_x, yi);
+		clip_append_vertex(ctx, x, y);
+		break;
+	case PATH_TRANSITION_OUT_TO_OUT:
+		/* nothing */
+		break;
+	default:
+		assert(0 && "bad enum path_transition");
+	}
+
+	ctx->prev.x = x;
+	ctx->prev.y = y;
+}
+
+static void
+clip_polygon_topbottom(struct clip_context *ctx,
+		       enum path_transition transition,
+		       float x, float y, float clip_y)
+{
+	float xi;
+
+	switch (transition) {
+	case PATH_TRANSITION_IN_TO_IN:
+		clip_append_vertex(ctx, x, y);
+		break;
+	case PATH_TRANSITION_IN_TO_OUT:
+		xi = clip_intersect_x(ctx->prev.x, ctx->prev.y, x, y, clip_y);
+		clip_append_vertex(ctx, xi, clip_y);
+		break;
+	case PATH_TRANSITION_OUT_TO_IN:
+		xi = clip_intersect_x(ctx->prev.x, ctx->prev.y, x, y, clip_y);
+		clip_append_vertex(ctx, xi, clip_y);
+		clip_append_vertex(ctx, x, y);
+		break;
+	case PATH_TRANSITION_OUT_TO_OUT:
+		/* nothing */
+		break;
+	default:
+		assert(0 && "bad enum path_transition");
+	}
+
+	ctx->prev.x = x;
+	ctx->prev.y = y;
+}
+
+static void
+clip_context_prepare(struct clip_context *ctx, const struct polygon8 *src,
+		      float *dst_x, float *dst_y)
+{
+	ctx->prev.x = src->x[src->n - 1];
+	ctx->prev.y = src->y[src->n - 1];
+	ctx->vertices.x = dst_x;
+	ctx->vertices.y = dst_y;
+}
+
+static int
+clip_polygon_left(struct clip_context *ctx, const struct polygon8 *src,
+		  float *dst_x, float *dst_y)
+{
+	enum path_transition trans;
+	int i;
+
+	clip_context_prepare(ctx, src, dst_x, dst_y);
+	for (i = 0; i < src->n; i++) {
+		trans = path_transition_left_edge(ctx, src->x[i], src->y[i]);
+		clip_polygon_leftright(ctx, trans, src->x[i], src->y[i],
+				       ctx->clip.x1);
+	}
+	return ctx->vertices.x - dst_x;
+}
+
+static int
+clip_polygon_right(struct clip_context *ctx, const struct polygon8 *src,
+		   float *dst_x, float *dst_y)
+{
+	enum path_transition trans;
+	int i;
+
+	clip_context_prepare(ctx, src, dst_x, dst_y);
+	for (i = 0; i < src->n; i++) {
+		trans = path_transition_right_edge(ctx, src->x[i], src->y[i]);
+		clip_polygon_leftright(ctx, trans, src->x[i], src->y[i],
+				       ctx->clip.x2);
+	}
+	return ctx->vertices.x - dst_x;
+}
+
+static int
+clip_polygon_top(struct clip_context *ctx, const struct polygon8 *src,
+		 float *dst_x, float *dst_y)
+{
+	enum path_transition trans;
+	int i;
+
+	clip_context_prepare(ctx, src, dst_x, dst_y);
+	for (i = 0; i < src->n; i++) {
+		trans = path_transition_top_edge(ctx, src->x[i], src->y[i]);
+		clip_polygon_topbottom(ctx, trans, src->x[i], src->y[i],
+				       ctx->clip.y1);
+	}
+	return ctx->vertices.x - dst_x;
+}
+
+static int
+clip_polygon_bottom(struct clip_context *ctx, const struct polygon8 *src,
+		    float *dst_x, float *dst_y)
+{
+	enum path_transition trans;
+	int i;
+
+	clip_context_prepare(ctx, src, dst_x, dst_y);
+	for (i = 0; i < src->n; i++) {
+		trans = path_transition_bottom_edge(ctx, src->x[i], src->y[i]);
+		clip_polygon_topbottom(ctx, trans, src->x[i], src->y[i],
+				       ctx->clip.y2);
+	}
+	return ctx->vertices.x - dst_x;
+}
+
+#define max(a, b) (((a) > (b)) ? (a) : (b))
+#define min(a, b) (((a) > (b)) ? (b) : (a))
+#define clip(x, a, b)  min(max(x, a), b)
+
+/*
+ * Compute the boundary vertices of the intersection of the global coordinate
+ * aligned rectangle 'rect', and an arbitrary quadrilateral produced from
+ * 'surf_rect' when transformed from surface coordinates into global coordinates.
+ * The vertices are written to 'ex' and 'ey', and the return value is the
+ * number of vertices. Vertices are produced in clockwise winding order.
+ * Guarantees to produce either zero vertices, or 3-8 vertices with non-zero
+ * polygon area.
+ */
+static int
+calculate_edges(struct weston_surface *es, pixman_box32_t *rect,
+		pixman_box32_t *surf_rect, float *ex, float *ey)
+{
+	struct polygon8 polygon;
+	struct clip_context ctx;
+	int i, n;
+	float min_x, max_x, min_y, max_y;
+	struct polygon8 surf = {
+		{ surf_rect->x1, surf_rect->x2, surf_rect->x2, surf_rect->x1 },
+		{ surf_rect->y1, surf_rect->y1, surf_rect->y2, surf_rect->y2 },
+		4
+	};
+
+	ctx.clip.x1 = rect->x1;
+	ctx.clip.y1 = rect->y1;
+	ctx.clip.x2 = rect->x2;
+	ctx.clip.y2 = rect->y2;
+
+	/* transform surface to screen space: */
+	for (i = 0; i < surf.n; i++)
+		weston_surface_to_global_float(es, surf.x[i], surf.y[i],
+					       &surf.x[i], &surf.y[i]);
+
+	/* find bounding box: */
+	min_x = max_x = surf.x[0];
+	min_y = max_y = surf.y[0];
+
+	for (i = 1; i < surf.n; i++) {
+		min_x = min(min_x, surf.x[i]);
+		max_x = max(max_x, surf.x[i]);
+		min_y = min(min_y, surf.y[i]);
+		max_y = max(max_y, surf.y[i]);
+	}
+
+	/* First, simple bounding box check to discard early transformed
+	 * surface rects that do not intersect with the clip region:
+	 */
+	if ((min_x >= ctx.clip.x2) || (max_x <= ctx.clip.x1) ||
+	    (min_y >= ctx.clip.y2) || (max_y <= ctx.clip.y1))
+		return 0;
+
+	/* Simple case, bounding box edges are parallel to surface edges,
+	 * there will be only four edges.  We just need to clip the surface
+	 * vertices to the clip rect bounds:
+	 */
+
+	if (!es->transform.enabled) {
+		for (i = 0; i < surf.n; i++) {
+			ex[i] = clip(surf.x[i], ctx.clip.x1, ctx.clip.x2);
+			ey[i] = clip(surf.y[i], ctx.clip.y1, ctx.clip.y2);
+		}
+		return surf.n;
+	}
+
+	/* Transformed case: use a general polygon clipping algorithm to
+	 * clip the surface rectangle with each side of 'rect'.
+	 * The algorithm is Sutherland-Hodgman, as explained in
+	 * http://www.codeguru.com/cpp/misc/misc/graphics/article.php/c8965/Polygon-Clipping.htm
+	 * but without looking at any of that code.
+	 */
+	polygon.n = clip_polygon_left(&ctx, &surf, polygon.x, polygon.y);
+	surf.n = clip_polygon_right(&ctx, &polygon, surf.x, surf.y);
+	polygon.n = clip_polygon_top(&ctx, &surf, polygon.x, polygon.y);
+	surf.n = clip_polygon_bottom(&ctx, &polygon, surf.x, surf.y);
+
+	/* Get rid of duplicate vertices */
+	ex[0] = surf.x[0];
+	ey[0] = surf.y[0];
+	n = 1;
+	for (i = 1; i < surf.n; i++) {
+		if (float_difference(ex[n - 1], surf.x[i]) == 0.0f &&
+		    float_difference(ey[n - 1], surf.y[i]) == 0.0f)
+			continue;
+		ex[n] = surf.x[i];
+		ey[n] = surf.y[i];
+		n++;
+	}
+	if (float_difference(ex[n - 1], surf.x[0]) == 0.0f &&
+	    float_difference(ey[n - 1], surf.y[0]) == 0.0f)
+		n--;
+
+	if (n < 3)
+		return 0;
+
+	return n;
+}
+
+static inline struct gal2d_output_state *
+get_output_state(struct weston_output *output)
+{
+	return (struct gal2d_output_state *)output->renderer_state;
+}
+
+static inline struct gal2d_surface_state *
+get_surface_state(struct weston_surface *surface)
+{
+	return (struct gal2d_surface_state *)surface->renderer_state;
+}
+
+static inline struct gal2d_renderer *
+get_renderer(struct weston_compositor *ec)
+{
+	return (struct gal2d_renderer *)ec->renderer;
+}
+
+static gctUINT32
+galGetStretchFactor(gctINT32 SrcSize, gctINT32 DestSize)
+{
+	gctUINT stretchFactor;
+	if ( (SrcSize > 0) && (DestSize > 1) )
+	{
+		stretchFactor = ((SrcSize - 1) << 16) / (DestSize - 1);
+	}
+	else
+	{
+		stretchFactor = 0;
+	}
+	return stretchFactor;
+}
+
+static gceSTATUS
+galGetStretchFactors(
+	IN gcsRECT_PTR SrcRect,
+	IN gcsRECT_PTR DestRect,
+	OUT gctUINT32 * HorFactor,
+	OUT gctUINT32 * VerFactor
+	)
+{
+	if (HorFactor != gcvNULL)
+	{
+        gctINT32 src, dest;
+
+        /* Compute width of rectangles. */
+        gcmVERIFY_OK(gcsRECT_Width(SrcRect, &src));
+        gcmVERIFY_OK(gcsRECT_Width(DestRect, &dest));
+
+        /* Compute and return horizontal stretch factor. */
+		*HorFactor = galGetStretchFactor(src, dest);
+	}
+
+	if (VerFactor != gcvNULL)
+	{
+		gctINT32 src, dest;
+
+		/* Compute height of rectangles. */
+		gcmVERIFY_OK(gcsRECT_Height(SrcRect, &src));
+		gcmVERIFY_OK(gcsRECT_Height(DestRect, &dest));
+
+		/* Compute and return vertical stretch factor. */
+		*VerFactor = galGetStretchFactor(src, dest);
+	}
+    /* Success. */
+    return gcvSTATUS_OK;
+}
+
+static gceSTATUS
+gal2d_getSurfaceFormat(halDISPLAY_INFO info, gceSURF_FORMAT * Format)
+{
+	/* Get the color format. */
+    switch (info.greenLength)
+    {
+    case 4:
+        if (info.blueOffset == 0)
+        {
+            *Format = (info.alphaLength == 0) ? gcvSURF_X4R4G4B4 : gcvSURF_A4R4G4B4;
+        }
+        else
+        {
+            *Format = (info.alphaLength == 0) ? gcvSURF_X4B4G4R4 : gcvSURF_A4B4G4R4;
+        }
+        break;
+
+    case 5:
+        if (info.blueOffset == 0)
+        {
+            *Format = (info.alphaLength == 0) ? gcvSURF_X1R5G5B5 : gcvSURF_A1R5G5B5;
+        }
+        else
+        {
+            *Format = (info.alphaLength == 0) ? gcvSURF_X1B5G5R5 : gcvSURF_A1B5G5R5;
+        }
+        break;
+
+    case 6:
+        *Format = gcvSURF_R5G6B5;
+        break;
+
+    case 8:
+        if (info.blueOffset == 0)
+        {
+            *Format = (info.alphaLength == 0) ? gcvSURF_X8R8G8B8 : gcvSURF_A8R8G8B8;
+        }
+        else
+        {
+            *Format = (info.alphaLength == 0) ? gcvSURF_X8B8G8R8 : gcvSURF_A8B8G8R8;
+        }
+        break;
+
+    default:
+        /* Unsupported color depth. */
+        return gcvSTATUS_INVALID_ARGUMENT;
+    }
+	/* Success. */
+    return gcvSTATUS_OK;
+}
+
+static gceSTATUS galIsYUVFormat(IN gceSURF_FORMAT Format)
+{
+    switch (Format)
+    {
+    case gcvSURF_YUY2:
+    case gcvSURF_UYVY:
+    case gcvSURF_I420:
+    case gcvSURF_YV12:
+    case gcvSURF_NV16:
+    case gcvSURF_NV12:
+    case gcvSURF_NV61:
+    case gcvSURF_NV21:
+
+        return gcvSTATUS_TRUE;
+
+    default:
+        return gcvSTATUS_FALSE;
+    }
+}
+
+static gceSTATUS galQueryUVStride(
+    IN gceSURF_FORMAT Format,
+    IN gctUINT32 yStride,
+    OUT gctUINT32_PTR uStride,
+    OUT gctUINT32_PTR vStride
+    )
+{
+    switch (Format)
+    {
+    case gcvSURF_YUY2:
+    case gcvSURF_UYVY:
+        *uStride = *vStride = 0;
+        break;
+
+    case gcvSURF_I420:
+    case gcvSURF_YV12:
+        *uStride = *vStride = yStride / 2;
+        break;
+
+    case gcvSURF_NV16:
+    case gcvSURF_NV12:
+    case gcvSURF_NV61:
+    case gcvSURF_NV21:
+
+        *uStride = yStride;
+        *vStride = 0;
+        break;
+
+    default:
+        return gcvSTATUS_NOT_SUPPORTED;
+    }
+
+    return gcvSTATUS_OK;
+}
+
+static int
+make_current(struct gal2d_renderer *gr, gcoSURF surface)
+{    
+	gceSTATUS status = gcvSTATUS_OK;
+	gctUINT width = 0;
+	gctUINT height = 0;
+	gctINT stride = 0;
+	gctUINT32 physical;
+	gctPOINTER va =0;
+
+	if(!surface)
+		goto OnError;
+    
+
+	gcmONERROR(gcoSURF_GetAlignedSize(surface, &width, &height, &stride));
+    
+	gcmONERROR(gcoSURF_Lock(surface, &physical, (gctPOINTER *)&va));
+
+	gcmONERROR(gco2D_SetTargetEx(gr->gcoEngine2d, physical, stride,
+									gcvSURF_0_DEGREE, width, height));
+                                   
+	gcmONERROR(gcoSURF_Unlock(surface, (gctPOINTER *)&va));
+    
+OnError:
+    galONERROR(status);
+	return status;
+}
+
+static gceSTATUS
+gal2d_clear(struct weston_output *base)
+{
+    struct gal2d_renderer *gr = get_renderer(base->compositor);
+	struct gal2d_output_state *go = get_output_state(base);    
+	gceSTATUS status = gcvSTATUS_OK;
+	
+	gctINT stride = 0;
+	gctUINT width = 0, height = 0;
+	gcsRECT dstRect = {0};
+	gcmONERROR(gcoSURF_GetAlignedSize(go->renderSurf[go->activebuffer],
+					&width, &height, &stride));
+	dstRect.right = width;
+	dstRect.bottom = height;
+	gcmONERROR(gco2D_SetSource(gr->gcoEngine2d, &dstRect));
+	gcmONERROR(gco2D_SetClipping(gr->gcoEngine2d, &dstRect));
+	gcmONERROR(gco2D_Clear(gr->gcoEngine2d, 1, &dstRect, 0xff0000ff, 0xCC, 0xCC, go->format));
+
+	gcmONERROR(gcoHAL_Commit(gr->gcoHal, gcvFALSE));
+
+OnError:
+	galONERROR(status);
+    
+	return status;
+}
+
+static gcoSURF getSurfaceFromShm(struct weston_surface *es, struct weston_buffer *buffer)
+{	
+    struct gal2d_renderer *gr = get_renderer(es->compositor);
+	
+	gcoSURF surface = 0;
+	gceSURF_FORMAT format;
+	gcePOOL pool = gcvPOOL_DEFAULT;
+
+	if (wl_shm_buffer_get_format(buffer->shm_buffer) == WL_SHM_FORMAT_XRGB8888)
+		format = gcvSURF_X8R8G8B8;
+	else
+		format = gcvSURF_A8R8G8B8;
+
+	if(buffer->width == ((buffer->width + 0x7) & ~0x7))
+	{
+		pool = gcvPOOL_USER;
+	}
+
+	gcmVERIFY_OK(gcoSURF_Construct(gr->gcoHal,
+						  (gctUINT) buffer->width,
+						  (gctUINT) buffer->height,
+						  1, gcvSURF_BITMAP,
+						  format, pool, &surface));
+
+	if(pool == gcvPOOL_USER)
+	{
+		gcmVERIFY_OK(gcoSURF_MapUserSurface(surface, 1,
+					(gctPOINTER)wl_shm_buffer_get_data(buffer->shm_buffer), gcvINVALID_ADDRESS));
+	}
+
+	return surface;
+}
+
+static int
+gal2dBindBuffer(struct weston_surface* es)
+{
+    struct gal2d_surface_state *gs = get_surface_state(es);
+	gceSTATUS status = gcvSTATUS_OK;
+	gcoSURF surface = gs->gco_Surface;	
+    struct weston_buffer *buffer = gs->buffer_ref.buffer;
+	gcePOOL pool = gcvPOOL_DEFAULT;
+	gctUINT64 node = 0;
+	gctUINT bytes;
+
+	gcmONERROR(gcoSURF_QueryVidMemNode(surface, &node,
+						&pool, &bytes));
+
+	if(pool != gcvPOOL_USER)
+	{
+		gctUINT alignedWidth;
+		gctPOINTER logical = (gctPOINTER)wl_shm_buffer_get_data(buffer->shm_buffer);
+		gctPOINTER va =0;
+
+
+		gcmONERROR(gcoSURF_GetAlignedSize(surface, &alignedWidth, gcvNULL, gcvNULL));
+		gcmONERROR(gcoSURF_Lock(surface, gcvNULL, (gctPOINTER *)&va));
+      
+		if(alignedWidth == (unsigned int)buffer->width)
+		{
+			int size = wl_shm_buffer_get_stride(buffer->shm_buffer)*buffer->height;
+			memcpy(va, logical, size);
+		}
+		else
+		{
+			int i, j;
+			for (i = 0; i < buffer->height; i++)
+			{
+				for (j = 0; j < buffer->width; j++)
+				{
+					gctUINT dstOff = i * alignedWidth + j;
+					gctUINT srcOff = (i * buffer->width + j);
+
+					memcpy(va + dstOff * 4, logical + srcOff * 4, 4);
+				}
+			}
+		}
+		gcmONERROR(gcoSURF_Unlock(surface, (gctPOINTER)va));
+	}
+
+OnError:
+    galONERROR(status);
+	return status;
+}
+
+static void
+gal2d_flip_surface(struct weston_output *output)
+{
+	struct gal2d_renderer *gr = get_renderer(output->compositor);
+	struct gal2d_output_state *go = get_output_state(output);
+	gceSTATUS status = gcvSTATUS_OK;
+
+
+	if(go->nNumBuffers > 1)
+	{
+		gctUINT Offset;
+		gctINT X;
+		gctINT Y;
+		gcoHAL_Commit(gr->gcoHal, gcvTRUE);
+
+		gcmONERROR(gcoOS_GetDisplayBackbuffer(go->display, gcvNULL,
+									gcvNULL, gcvNULL, &Offset, &X, &Y));
+
+		gcmONERROR(gcoOS_SetDisplayVirtual(go->display, gcvNULL,
+									Offset, X, Y));
+
+		go->activebuffer = (go->activebuffer+1) % go->nNumBuffers;
+	}
+
+OnError:
+	galONERROR(status);
+}
+
+static int
+update_surface(struct weston_output *output)
+{
+    struct gal2d_renderer *gr = get_renderer(output->compositor);
+	struct gal2d_output_state *go = get_output_state(output);
+    gceSTATUS status = gcvSTATUS_OK;
+    
+
+
+    if(go->offscreenSurface && go->nNumBuffers == 1)
+	{
+		make_current(gr, go->renderSurf[go->activebuffer]);
+
+		gctUINT srcWidth = 0;
+		gctUINT srcHeight = 0;
+		gctINT srcStride = 0;
+		gceSURF_FORMAT srcFormat;;
+		gcsRECT dstRect = {0};
+		gcoSURF srcSurface = go->offscreenSurface;
+		gctUINT32 physical;
+		gctPOINTER va =0;
+
+		gcmONERROR(gcoSURF_GetAlignedSize(srcSurface, &srcWidth, &srcHeight, &srcStride));
+		gcmONERROR(gcoSURF_GetFormat(srcSurface, gcvNULL, &srcFormat));
+		gcmONERROR(gcoSURF_Lock(srcSurface, &physical, (gctPOINTER *)&va));
+		gcmONERROR(gco2D_SetColorSource(gr->gcoEngine2d, physical, srcStride, srcFormat,
+							gcvFALSE, srcWidth, gcvFALSE, gcvSURF_OPAQUE, 0));
+
+		dstRect.left 	= 0;
+		dstRect.top		= 0;
+		dstRect.right 	= srcWidth;
+		dstRect.bottom 	= srcHeight;
+
+		gcmONERROR(gco2D_SetSource(gr->gcoEngine2d, &dstRect));
+		gcmONERROR(gco2D_SetClipping(gr->gcoEngine2d, &dstRect));
+		gcmONERROR(gco2D_Blit(gr->gcoEngine2d, 1, &dstRect, 0xCC, 0xCC, go->format));
+		gcmONERROR(gcoSURF_Unlock(srcSurface, (gctPOINTER *)&va));
+		gcmONERROR(gcoHAL_Commit(gr->gcoHal, gcvFALSE));
+	}
+
+    gal2d_flip_surface(output);
+    
+OnError:
+	galONERROR(status);
+	return status;
+ }
+ 
+static int
+use_output(struct weston_output *output)
+{
+    struct gal2d_output_state *go = get_output_state(output);	
+	struct gal2d_renderer *gr = get_renderer(output->compositor);    
+    gceSTATUS status = gcvSTATUS_OK;
+
+    gcoSURF surface;
+	surface = go->nNumBuffers > 1 ?
+						go->renderSurf[go->activebuffer] :
+						go->offscreenSurface;  /*go->renderSurf[0];*/
+    make_current(gr, surface); 
+    return status;
+}
+
+static int
+gal2d_renderer_read_pixels(struct weston_output *output,
+			       pixman_format_code_t format, void *pixels,
+			       uint32_t x, uint32_t y,
+			       uint32_t width, uint32_t height)
+{
+	return 0;
+}
+
+static int gal2d_int_from_double(double d)
+{
+	return wl_fixed_to_int(wl_fixed_from_double(d));
+}
+
+static void
+repaint_region(struct weston_surface *es, struct weston_output *output, struct gal2d_output_state *go, pixman_region32_t *region,
+		pixman_region32_t *surf_region){
+
+    struct gal2d_renderer *gr = get_renderer(es->compositor);
+    struct gal2d_surface_state *gs = get_surface_state(es);
+
+	pixman_box32_t *rects, *surf_rects, *bb_rects;
+	int i, j, nrects, nsurf, nbb=0;
+	gceSTATUS status = gcvSTATUS_OK;
+	gcoSURF srcSurface = gs->gco_Surface;
+	gcsRECT srcRect = {0};
+	gcsRECT dstrect = {0};
+	gctUINT32 horFactor, verFactor;
+	int useStretch =1;
+	int useFilterBlit = 0;
+	gctUINT srcWidth = 0;
+	gctUINT srcHeight = 0;
+	gctUINT32 srcStride[3];
+	gceSURF_FORMAT srcFormat;;
+	gctUINT32 srcPhyAddr[3];
+	gctUINT32 dstPhyAddr[3];
+	gctUINT dstWidth = 0;
+	gctUINT dstHeight = 0;
+	gctUINT32 dstStrides[3];
+	gcoSURF dstsurface;
+	int geoWidth = es->geometry.width;
+	int geoheight = es->geometry.height;
+
+	bb_rects = pixman_region32_rectangles(&es->transform.boundingbox, &nbb);
+
+	if(!srcSurface || nbb <= 0)
+		goto OnError;
+	rects = pixman_region32_rectangles(region, &nrects);
+	surf_rects = pixman_region32_rectangles(surf_region, &nsurf);
+
+	gcmONERROR(gcoSURF_GetAlignedSize(srcSurface, &srcWidth, &srcHeight, (gctINT *)&srcStride[0]));
+
+	/*gcmONERROR(gcoSURF_GetSize(srcSurface, &srcWidth, &srcHeight, gcvNULL));*/
+	gcmONERROR(gcoSURF_GetFormat(srcSurface, gcvNULL, &srcFormat));
+
+	if(galIsYUVFormat(srcFormat) == gcvSTATUS_TRUE)
+	{
+		useFilterBlit = 1;
+	}
+
+	gcmONERROR(gcoSURF_Lock(srcSurface, &srcPhyAddr[0], gcvNULL));
+
+	gcmONERROR(gcoSURF_Unlock(srcSurface, gcvNULL));
+
+	srcRect.left = es->geometry.x < 0.0 ? gal2d_int_from_double(fabsf(es->geometry.x)) : 0;
+	srcRect.top = 0; /*es->geometry.y < 0.0 ? gal2d_int_from_double(fabsf(es->geometry.y)) : 0;*/
+	srcRect.right = es->geometry.width;
+	srcRect.bottom = es->geometry.height;
+
+	if(useFilterBlit)
+	{
+		dstsurface = go->nNumBuffers > 1 ?
+						go->renderSurf[go->activebuffer] :
+						go->offscreenSurface;
+		gcmONERROR(gcoSURF_GetAlignedSize(dstsurface, &dstWidth, &dstHeight, (gctINT *)&dstStrides));
+		gcmONERROR(gcoSURF_Lock(dstsurface, &dstPhyAddr[0], gcvNULL));
+		gcmONERROR(gcoSURF_Unlock(dstsurface, gcvNULL));
+	}
+	else
+	{
+		/*printf("%s:%d height=%d %d srcWidth=%d\n",__func__,__LINE__,srcHeight, srcStride[0],srcWidth);*/
+		gcmONERROR(gco2D_SetColorSourceEx(gr->gcoEngine2d, srcPhyAddr[0], srcStride[0], srcFormat,
+						gcvFALSE, srcWidth, srcHeight, gcvFALSE, gcvSURF_OPAQUE, 0));
+		gcmONERROR(gco2D_SetSource(gr->gcoEngine2d, &srcRect));
+	}
+
+	for (i = 0; i < nrects; i++)
+	{
+		pixman_box32_t *rect = &rects[i];
+		gctFLOAT min_x, max_x, min_y, max_y;
+
+		dstrect.left = (bb_rects[0].x1 < 0) ? rect->x1 : bb_rects[0].x1;
+		dstrect.top = (bb_rects[0].y1 < 0) ? rect->y1 : bb_rects[0].y1;
+		dstrect.right = bb_rects[0].x2;
+		dstrect.bottom = bb_rects[0].y2;
+
+		if(dstrect.right < 0 || dstrect.bottom < 0)
+		{
+			break;
+		}
+
+		for (j = 0; j < nsurf; j++)
+		{
+			pixman_box32_t *surf_rect = &surf_rects[j];
+			gctFLOAT ex[8], ey[8];          /* edge points in screen space */
+			int n;
+			gcsRECT clipRect = {0};
+			int m=0;
+			n = calculate_edges(es, rect, surf_rect, ex, ey);
+			if (n < 3)
+				continue;
+
+			min_x = max_x = ex[0];
+			min_y = max_y = ey[0];
+			for (m = 1; m < n; m++)
+			{
+				min_x = min(min_x, ex[m]);
+				max_x = max(max_x, ex[m]);
+				min_y = min(min_y, ey[m]);
+				max_y = max(max_y, ey[m]);
+			}
+
+			clipRect.left = gal2d_int_from_double(min_x);
+			clipRect.top = gal2d_int_from_double(min_y);
+			clipRect.right = gal2d_int_from_double(max_x);
+			clipRect.bottom = gal2d_int_from_double(max_y);
+
+			if(output->x > 0)
+			{
+				dstrect.left = dstrect.left - output->x;
+				dstrect.right = dstrect.right - output->x;
+				clipRect.left = clipRect.left - output->x;
+				clipRect.right = clipRect.right - output->x;
+			}
+
+
+			dstrect.left = (dstrect.left < 0) ? 0 : dstrect.left;
+			
+			status = gco2D_SetClipping(gr->gcoEngine2d, &clipRect);
+			if(status < 0)
+			{
+				weston_log("Error in gco2D_SetClipping %s\n", __func__);
+				goto OnError;
+			}
+
+			if(useFilterBlit)
+			{
+				gctINT          srcStrideNum;
+				gctINT          srcAddressNum;
+				gcmONERROR(galQueryUVStride(srcFormat, srcStride[0],
+						&srcStride[1], &srcStride[2]));
+
+				switch (srcFormat)
+				{
+				case gcvSURF_YUY2:
+				case gcvSURF_UYVY:
+					srcStrideNum = srcAddressNum = 1;
+					break;
+
+				case gcvSURF_I420:
+				case gcvSURF_YV12:
+					srcStrideNum = srcAddressNum = 3;
+					break;
+
+				case gcvSURF_NV16:
+				case gcvSURF_NV12:
+				case gcvSURF_NV61:
+				case gcvSURF_NV21:
+					srcStrideNum = srcAddressNum = 2;
+					break;
+
+				default:
+					gcmONERROR(gcvSTATUS_NOT_SUPPORTED);
+				}
+				gco2D_FilterBlitEx2(gr->gcoEngine2d,
+					srcPhyAddr, srcAddressNum,
+					srcStride, srcStrideNum,
+					gcvLINEAR, srcFormat, gcvSURF_0_DEGREE,
+					geoWidth, geoheight, &srcRect,
+					dstPhyAddr, 1,
+					dstStrides, 1,
+					gcvLINEAR, go->format, gcvSURF_0_DEGREE,
+					dstWidth, dstHeight,
+					&dstrect, gcvNULL);
+			}
+			else
+			{
+				if(useStretch)
+					status = (galGetStretchFactors(&srcRect, &dstrect, &horFactor, &verFactor));
+				if(status < 0)
+				{
+					printf("Error in galGetStretchFactors %s\n", __func__);
+					goto OnError;
+				}
+
+				if(verFactor == 65536 && horFactor == 65536)
+				{
+					status = (gco2D_Blit(gr->gcoEngine2d, 1, &dstrect,
+						0xCC, 0xCC, go->format));
+				}
+				else
+				{
+					/* Program the stretch factors. */
+					status = (gco2D_SetStretchFactors(gr->gcoEngine2d, horFactor, verFactor));
+					if(status < 0)
+					{
+						printf("Error in gco2D_SetStretchFactors %s\n", __func__);
+						goto OnError;
+					}
+					status = (gco2D_StretchBlit(gr->gcoEngine2d, 1, &dstrect,
+							0xCC, 0xCC, go->format));
+				}
+			}
+			if(status < 0)
+			{
+				printf("Error in Blit %s\n", __func__);
+				printf("cr l=%d r=%d t=%d b=%d w=%d h=%d\n",
+					clipRect.left, clipRect.right, clipRect.top ,clipRect.bottom,
+					clipRect.right - clipRect.left, clipRect.bottom -clipRect.top);
+				printf("dr l=%d r=%d t=%d b=%d w=%d h=%d\n",
+						dstrect.left, dstrect.right, dstrect.top ,dstrect.bottom,
+						dstrect.right - dstrect.left, dstrect.bottom -dstrect.top);
+				printf("horFactor=%d, verFactor=%d\n",horFactor, verFactor);
+
+				printf("geo x=%f y=%f x=%d y=%d w=%d h=%d \n",
+						es->geometry.x, es->geometry.y,
+						gal2d_int_from_double(es->geometry.x),
+						gal2d_int_from_double(es->geometry.y),
+					 es->geometry.width,es->geometry.height);
+				goto OnError;
+			}
+		}
+		status = (gcoHAL_Commit(gr->gcoHal, gcvFALSE));
+		if(status < 0)
+		{
+			printf("Error in gcoHAL_Commit %s\n", __func__);
+			goto OnError;
+		}
+	}
+
+OnError:
+	galONERROR(status);
+}
+
+static void
+draw_surface(struct weston_surface *es, struct weston_output *output,
+	     pixman_region32_t *damage) /* in global coordinates */
+{
+	struct weston_compositor *ec = es->compositor;	
+	struct gal2d_output_state *go = get_output_state(output);
+	/* repaint bounding region in global coordinates: */
+	pixman_region32_t repaint;
+	/* non-opaque region in surface coordinates: */
+	pixman_region32_t surface_blend;
+	pixman_region32_t *buffer_damage;
+
+    pixman_region32_init(&repaint);
+	pixman_region32_intersect(&repaint,
+				  &es->transform.boundingbox, damage);
+	pixman_region32_subtract(&repaint, &repaint, &es->clip);
+
+	if (!pixman_region32_not_empty(&repaint))
+		goto out;
+
+	buffer_damage = &go->buffer_damage[go->current_buffer];
+	pixman_region32_subtract(buffer_damage, buffer_damage, &repaint);
+
+	/* blended region is whole surface minus opaque region: */
+	pixman_region32_init_rect(&surface_blend, 0, 0,
+				  es->geometry.width, es->geometry.height);
+	pixman_region32_subtract(&surface_blend, &surface_blend, &es->opaque);
+
+	if (pixman_region32_not_empty(&es->opaque)) {			
+
+		repaint_region(es, output, go, &repaint, &es->opaque);
+	}
+
+	if (pixman_region32_not_empty(&surface_blend)) {
+        struct gal2d_renderer *gr = get_renderer(ec);
+        
+        gco2D_EnableAlphaBlend(gr->gcoEngine2d,
+			es->alpha * 0xFF, es->alpha * 0xFF,
+			gcvSURF_PIXEL_ALPHA_STRAIGHT, gcvSURF_PIXEL_ALPHA_STRAIGHT,
+			gcvSURF_GLOBAL_ALPHA_OFF, gcvSURF_GLOBAL_ALPHA_OFF,
+			gcvSURF_BLEND_ONE, gcvSURF_BLEND_INVERSED,
+			gcvSURF_COLOR_STRAIGHT, gcvSURF_COLOR_STRAIGHT);
+            
+		repaint_region(es, output, go, &repaint, &surface_blend);
+	}
+
+	pixman_region32_fini(&surface_blend);
+
+out:
+	pixman_region32_fini(&repaint);
+
+}
+
+static void
+repaint_surfaces(struct weston_output *output, pixman_region32_t *damage)
+{
+	struct weston_compositor *compositor = output->compositor;
+	struct weston_surface *surface;
+
+	wl_list_for_each_reverse(surface, &compositor->surface_list, link)
+		if (surface->plane == &compositor->primary_plane)
+			draw_surface(surface, output, damage);
+
+            
+}
+
+static void
+gal2d_renderer_repaint_output(struct weston_output *output,
+			     pixman_region32_t *output_damage)
+{
+    struct gal2d_output_state *go = get_output_state(output);	
+ 	gctUINT32 i;
+
+	if (use_output(output) < 0)
+		return;
+        
+	for (i = 0; i < 2; i++)
+		pixman_region32_union(&go->buffer_damage[i],
+				      &go->buffer_damage[i],
+				      output_damage);
+
+	pixman_region32_union(output_damage, output_damage,
+			      &go->buffer_damage[go->current_buffer]);
+
+	repaint_surfaces(output, output_damage);
+
+	/*if (gr->border.texture)
+		draw_border(output);*/
+
+	pixman_region32_copy(&output->previous_damage, output_damage);
+	wl_signal_emit(&output->frame_signal, output);
+    
+    update_surface(output);
+
+	go->current_buffer ^= 1;
+
+}
+
+static void
+gal2d_renderer_flush_damage(struct weston_surface *surface)
+{
+	struct gal2d_surface_state *gs = get_surface_state(surface);
+	struct weston_buffer *buffer = gs->buffer_ref.buffer;
+
+	pixman_region32_union(&gs->texture_damage,
+			      &gs->texture_damage, &surface->damage);
+
+	if (!buffer)
+		return;
+
+	/* Avoid upload, if the texture won't be used this time.
+	 * We still accumulate the damage in texture_damage, and
+	 * hold the reference to the buffer, in case the surface
+	 * migrates back to the primary plane.
+	 */
+	if (surface->plane != &surface->compositor->primary_plane)
+		return;
+	if (!pixman_region32_not_empty(&gs->texture_damage))
+		goto done;
+
+    if(wl_shm_buffer_get(buffer->resource))
+	{
+		if(gs->gco_Surface==NULL)
+		{
+			gs->gco_Surface = getSurfaceFromShm(surface, buffer);
+		}
+		gal2dBindBuffer(surface);
+	}
+	else
+	{
+		gcsWL_VIV_BUFFER *vivBuffer = (gcsWL_VIV_BUFFER *)buffer;
+		gs->gco_Surface = vivBuffer->surface;
+	}
+
+done:
+	pixman_region32_fini(&gs->texture_damage);
+	pixman_region32_init(&gs->texture_damage);
+
+	weston_buffer_reference(&gs->buffer_ref, NULL);
+}
+
+static void
+gal2d_renderer_attach(struct weston_surface *es, struct weston_buffer *buffer)
+{
+	struct gal2d_surface_state *gs = get_surface_state(es);
+	struct wl_shm_buffer *shm_buffer;
+	weston_buffer_reference(&gs->buffer_ref, buffer);
+
+	if(buffer==NULL)
+		return;
+
+	shm_buffer = wl_shm_buffer_get(buffer->resource);
+
+	if(shm_buffer)
+	{
+		buffer->width = wl_shm_buffer_get_width(shm_buffer);
+		buffer->height = wl_shm_buffer_get_height(shm_buffer);
+		buffer->shm_buffer = shm_buffer;
+
+		if(gs->gco_Surface)
+		{
+			gcoSURF_Destroy(gs->gco_Surface);
+            gs->gco_Surface = getSurfaceFromShm(es, buffer);
+		}
+	}
+	else
+	{
+		gcsWL_VIV_BUFFER *vivBuffer = wl_resource_get_user_data(buffer->resource);
+		gs->gco_Surface = vivBuffer->surface;
+
+		buffer->width = vivBuffer->width;
+		buffer->height = vivBuffer->height;
+	}
+
+}
+
+static int
+gal2d_renderer_create_surface(struct weston_surface *surface)
+{
+    struct gal2d_surface_state *gs;
+
+	gs = calloc(1, sizeof *gs);
+	if (!gs)
+		return -1;
+
+	/* A buffer is never attached to solid color surfaces, yet
+	 * they still go through texcoord computations. Do not divide
+	 * by zero there.
+	 */
+	gs->pitch = 1;
+
+	pixman_region32_init(&gs->texture_damage);
+	surface->renderer_state = gs;
+
+	return 0;
+}
+
+static void
+gal2d_renderer_surface_set_color(struct weston_surface *surface,
+		 float red, float green, float blue, float alpha)
+{
+    struct gal2d_surface_state *gs = get_surface_state(surface);
+
+	gs->color[0] = red;
+	gs->color[1] = green;
+	gs->color[2] = blue;
+	gs->color[3] = alpha;
+}
+
+static void
+gal2d_renderer_destroy_surface(struct weston_surface *surface)
+{
+}
+
+WL_EXPORT void
+gal2d_renderer_output_destroy(struct weston_output *output)
+{
+    struct gal2d_output_state *go = get_output_state(output);
+    gctUINT32 i;
+    
+	if(go->nNumBuffers <= 1 )
+	{
+		if(go->offscreenSurface)
+			gcmVERIFY_OK(gcoSURF_Destroy(go->offscreenSurface));
+	}
+
+	for(i=0; i < go->nNumBuffers; i++)
+	{
+		gcmVERIFY_OK(gcoSURF_Destroy(go->renderSurf[i]));
+	}
+
+	free(go->renderSurf);
+	go->renderSurf = gcvNULL;
+
+	free(go);
+}
+
+static void
+gal2d_renderer_destroy(struct weston_compositor *ec)
+{    
+	free(ec->renderer);
+	ec->renderer = NULL;
+}
+
+
+WL_EXPORT int
+gal2d_renderer_create(struct weston_compositor *ec)
+{
+    struct gal2d_renderer *gr;
+    gceSTATUS status = gcvSTATUS_OK;
+	gr = malloc(sizeof *gr);
+	if (gr == NULL)
+		return -1;
+
+	gr->base.read_pixels = gal2d_renderer_read_pixels;
+	gr->base.repaint_output = gal2d_renderer_repaint_output;
+	gr->base.flush_damage = gal2d_renderer_flush_damage;
+	gr->base.attach = gal2d_renderer_attach;
+	gr->base.create_surface = gal2d_renderer_create_surface;
+	gr->base.surface_set_color = gal2d_renderer_surface_set_color;
+	gr->base.destroy_surface = gal2d_renderer_destroy_surface;
+	gr->base.destroy = gal2d_renderer_destroy;
+    
+    /* Construct the gcoOS object. */
+	gcmONERROR(gcoOS_Construct(gcvNULL, &gr->gcos));
+
+	/* Construct the gcoHAL object. */
+	gcmONERROR(gcoHAL_Construct(gcvNULL, gr->gcos, &gr->gcoHal));
+	gcmONERROR(gcoHAL_Get2DEngine(gr->gcoHal, &gr->gcoEngine2d));
+	gcmONERROR(gcoHAL_SetHardwareType(gr->gcoHal, gcvHARDWARE_2D));
+    
+	ec->renderer = &gr->base; 
+OnError:
+    galONERROR(status);
+    
+    /* Return the status. */    
+    return status;
+	
+}
+
+WL_EXPORT int
+gal2d_renderer_output_create(struct weston_output *output, EGLNativeDisplayType display,
+				    EGLNativeWindowType window)
+
+ {
+    struct gal2d_renderer *gr = get_renderer(output->compositor);
+	struct gal2d_output_state *go = calloc(1, sizeof *go);
+    halDISPLAY_INFO info;
+    gctUINT32 backOffset = 0;
+    gctINT width, height;
+    gceSTATUS status = gcvSTATUS_OK;
+	gctUINT32 i;
+    
+    if (!go)
+		return -1;
+     
+    output->renderer_state = go;
+    go->display = display;
+    gcmONERROR(gcoOS_InitLocalDisplayInfo(go->display, &gr->localInfo));
+
+    /* Get display information. */
+	gcmONERROR(gcoOS_GetDisplayInfoEx2(
+					go->display, gcvNULL, gr->localInfo,
+					sizeof(info), &info));
+	go->nNumBuffers = info.multiBuffer;
+    
+    weston_log("Number of buffers=%d\n",go->nNumBuffers);
+
+	gcmONERROR(gal2d_getSurfaceFormat(info, &go->format));    
+	backOffset = (gctUINT32)(info.stride * info.height );
+
+	go->activebuffer = 0;
+
+	go->renderSurf = malloc(sizeof(gcoSURF) * go->nNumBuffers);
+	gcoOS_GetDisplayVirtual(go->display, &width, &height);
+	for(i=0; i < go->nNumBuffers; i++)
+	{
+		
+        gcmONERROR(gcoSURF_Construct(gr->gcoHal, info.width, info.height, 1, 
+            gcvSURF_BITMAP, go->format, gcvPOOL_USER, &go->renderSurf[i]));
+        
+        gcoSURF_MapUserSurface(go->renderSurf[i], 0,info.logical + (i * backOffset),
+						info.physical + (i * backOffset));
+		
+		//Clear surfaces
+		make_current(gr, go->renderSurf[go->activebuffer]);
+		gal2d_clear(output);
+		gal2d_flip_surface(output);
+	}
+	if(go->nNumBuffers <= 1)
+		go->activebuffer = 0;
+	else
+		go->activebuffer = 1;
+
+	if(go->nNumBuffers <= 1 )
+	{
+		gcmVERIFY_OK(gcoSURF_Construct(gr->gcoHal,
+							  (gctUINT) info.width,
+							  (gctUINT) info.height,
+							  1,
+							  gcvSURF_BITMAP,
+							  go->format,
+							  gcvPOOL_DEFAULT,
+							  &go->offscreenSurface));
+		make_current(gr, go->offscreenSurface);
+		gal2d_clear(output);
+		gal2d_flip_surface(output);
+	}
+OnError:
+    galONERROR(status);
+    /* Return the status. */
+    return status;  
+ }
diff --git a/src/gal2d-renderer.h b/src/gal2d-renderer.h
new file mode 100644
index 0000000..915af26
--- /dev/null
+++ b/src/gal2d-renderer.h
@@ -0,0 +1,41 @@
+/*
+ * Copyright Â© 2013 Vasily Khoruzhick <anarsoul@gmail.com>
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and
+ * its documentation for any purpose is hereby granted without fee, provided
+ * that the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of the copyright holders not be used in
+ * advertising or publicity pertaining to distribution of the software
+ * without specific, written prior permission.  The copyright holders make
+ * no representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
+ * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#ifndef __gal_2d_renderer_h_
+#define __gal_2d_renderer_h_
+
+#include  "compositor.h"
+#include <EGL/egl.h>
+
+int
+gal2d_renderer_create(struct weston_compositor *ec);
+
+int
+gal2d_renderer_output_create(struct weston_output *output, EGLNativeDisplayType display,
+				    EGLNativeWindowType window);
+
+void
+gal2d_renderer_output_set_buffer(struct weston_output *output, pixman_image_t *buffer);
+
+void
+gal2d_renderer_output_destroy(struct weston_output *output);
+
+#endif
\ No newline at end of file
-- 
1.8.1.2

